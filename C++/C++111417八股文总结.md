# C++ 11 

## auto、decltype

auto 和 decltype 都是 C++11 新增的关键字，都用于自动类型推导，但是它们的语法格式是有区别的，如下所示：

```c++
auto varname = value; //auto的语法格式
decltype(exp) varname [= value]; //decltype的语法格式
```

**auto** 根据=右边的初始值 value 推导出变量的类型；
**decltype** 根据 exp 表达式推导出变量的类型，跟=右边的 value 没有关系。

当表达式的类型为引用时，auto 和 decltype 的推导规则也不一样；decltype 会保留引用类型，而 auto 会抛弃引用类型，直接推导出它的原始类型。

## using定义别名（替代typedef）



## lambda

lambda匿名函数中的[外部变量]
对于 lambda 匿名函数的使用，令多数初学者感到困惑的就是 [外部变量] 的使用。其实很简单，无非表 1 所示的这几种编写格式。

|  外部变量格式   |                             功能                             |
| :-------------: | :----------------------------------------------------------: |
|       []        |    空方括号表示当前 lambda 匿名函数中不导入任何外部变量。    |
|       [=]       |    只有一个 = 等号，表示以值传递的方式导入所有外部变量；     |
|       [&]       |   只有一个 & 符号，表示以引用传递的方式导入所有外部变量；    |
|  [val1,val2,…]  | 表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序； |
| [&val1,&val2,…] | 表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序； |
|  [val,&val2,…]  |     以上 2 种方式还可以混合使用，变量之间没有前后次序。      |
|   [=,&val1,…]   | 表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。 |
|     [this]      |           表示以值传递的方式导入当前的 this 指针。           |



## const、constexpr

### 对比

1. **编译时求值 vs. 运行时求值**
   - `const` 常量在编译时不一定已知，可以在运行时求值。例如，`const` 可以用于运行时从函数返回的值。
   - `constexpr` 保证在编译时求值，适用于编译时已知的常量表达式。
2. **函数定义**
   - `const` 不能用于函数定义，只能用于变量。
   - `constexpr` 可以用于定义常量表达式函数，这些函数可以在编译时求值。
3. **语义**
   - `const` 仅表示变量不可变，但不强制在编译时求值。
   - `constexpr` 确保变量或函数在编译时求值，从而支持更强的编译时优化。



## 右值引用

### 右值

​		右值引用可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。

​		左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是"left value"、“right value” 的缩写，其实不然。**lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据**，而 **rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）**。

通常情况下，判断某个表达式是左值还是右值，最常用的有以下 2 种方法。

1. **可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值**。举个例子：
   int a = 5;
   5 = a; //错误，5 不能为左值

   其中，变量 a 就是一个左值，而字面量 5 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用，例如：

   int b = 10; // b 是一个左值
   a = b; // a、b 都是左值，只不过将 b 可以当做右值使用

2. **有名称的、可以获取到存储地址的表达式即为左值；反之则是右值**。
   以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &a 和 &b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。

注意，以上 2 种判定方法只适用于大部分场景。

### 右值引用

​		C++11 标准新引入了另一种引用方式，称为右值引用，用 “&&” 表示。

​		需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：

```c++
int num = 10;
const int &b = num;
const int &c = 10;
```

​		和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：

```c++
int num = 10;
//int && a = num;  //右值引用不能初始化为左值
int && a = 10;
```


​		右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。

## 移动构造函数























# 14





# 17





# 20

