# C++ 11 

## auto、decltype

auto 和 decltype 都是 C++11 新增的关键字，都用于自动类型推导，但是它们的语法格式是有区别的，如下所示：

```c++
auto varname = value; //auto的语法格式
decltype(exp) varname [= value]; //decltype的语法格式
```

**auto** 根据=右边的初始值 value 推导出变量的类型；
**decltype** 根据 exp 表达式推导出变量的类型，跟=右边的 value 没有关系。

当表达式的类型为引用时，auto 和 decltype 的推导规则也不一样；decltype 会保留引用类型，而 auto 会抛弃引用类型，直接推导出它的原始类型。

## using定义别名（替代typedef）



## lambda

lambda匿名函数中的[外部变量]
对于 lambda 匿名函数的使用，令多数初学者感到困惑的就是 [外部变量] 的使用。其实很简单，无非表 1 所示的这几种编写格式。

|  外部变量格式   |                             功能                             |
| :-------------: | :----------------------------------------------------------: |
|       []        |    空方括号表示当前 lambda 匿名函数中不导入任何外部变量。    |
|       [=]       |    只有一个 = 等号，表示以值传递的方式导入所有外部变量；     |
|       [&]       |   只有一个 & 符号，表示以引用传递的方式导入所有外部变量；    |
|  [val1,val2,…]  | 表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序； |
| [&val1,&val2,…] | 表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序； |
|  [val,&val2,…]  |     以上 2 种方式还可以混合使用，变量之间没有前后次序。      |
|   [=,&val1,…]   | 表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。 |
|     [this]      |           表示以值传递的方式导入当前的 this 指针。           |



## const、constexpr

### 对比

1. **编译时求值 vs. 运行时求值**
   - `const` 常量在编译时不一定已知，可以在运行时求值。例如，`const` 可以用于运行时从函数返回的值。
   - `constexpr` 保证在编译时求值，适用于编译时已知的常量表达式。
2. **函数定义**
   - `const` 不能用于函数定义，只能用于变量。
   - `constexpr` 可以用于定义常量表达式函数，这些函数可以在编译时求值。
3. **语义**
   - `const` 仅表示变量不可变，但不强制在编译时求值。
   - `constexpr` 确保变量或函数在编译时求值，从而支持更强的编译时优化。



## 右值引用

### 右值

​		右值引用可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。

​		左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是"left value"、“right value” 的缩写，其实不然。**lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据**，而 **rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）**。

通常情况下，判断某个表达式是左值还是右值，最常用的有以下 2 种方法。

1. **可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值**。举个例子：
   int a = 5;
   5 = a; //错误，5 不能为左值

   其中，变量 a 就是一个左值，而字面量 5 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用，例如：

   int b = 10; // b 是一个左值
   a = b; // a、b 都是左值，只不过将 b 可以当做右值使用

2. **有名称的、可以获取到存储地址的表达式即为左值；反之则是右值**。
   以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &a 和 &b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。

注意，以上 2 种判定方法只适用于大部分场景。

### 右值引用

​		C++11 标准新引入了另一种引用方式，称为右值引用，用 “&&” 表示。

​		需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：

```c++
int num = 10;
const int &b = num;
const int &c = 10;
```

​		和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：

```c++
int num = 10;
//int && a = num;  //右值引用不能初始化为左值
int && a = 10;
```


​		右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。

## 移动构造函数

​		移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。



## move







## 完美转发



## 智能指针

### shared_ptr

- 构造函数也是 explicit 的，没有 delete 拷贝构造和赋值构造函数，所以可以共享
- 指向资源的指针增加了一个引用计数就加 1，指向资源的指针减少了一个引用计数就加 1
- 可以使用 move 将 share_ptr 抓换成 unique_ptr，反之不行
- **删除器：** 可以自定义删除器，可以为普通函数、仿函数和 Lambda 表达式



### unique_ptr

​		std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全。既然是独占， 换句话说就是不可复制。 但是， 我们可以利用 std::move 将其转移给其他的 unique_ptr

- 构造函数是 explicit 的，所以不能简单的赋值
- 禁用了拷贝构造函数和拷贝赋值函数，所以就实现了独享语义，unique_ptr 就是想用一个智能指针管理对象
- 不要用同一个裸指针初始化多个 unique_ptr
- release() 可以释放 unique_ptr 对原始指针的控制权，返回原始指针，get() 仅仅是返回原始指针
- 程序使用 exit() 退出时，全局的 unique_ptr 可以正常释放，但是局部的 unique_ptr 不会自动释放
- 

### weak_ptr

​		weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是强引用的 shared_ptr，weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, **它的构造和析构不会引起引用记数的增加或减少，通常用来打破 shared_ptr 的循环计数**

- weak_ptr 不控制对象的生命周期，但是它知道对象是否还活着
- 用 lock() 函数把它可以提升为shared_ptr，如果对象还活着，返回有效的shared_ptr，如果对象已经死了，提升会失败，返回一个空的shared ptr。
- 提升的行为 lock() 是线程安全的



## 其他

- **noexcept** 用于申明函数保证不会抛出异常，后面可以跟一个括号写一个条件，也就是说在某种条件满足情况下，不会抛出异常
- **override** 用于明确要重写父类的虚函数上，相当于告诉编译器这个函数就是要重写父类虚函数这样一个意图，让编译器帮忙检查，而没有这个关键字，编译器是不会帮你检查的
- **final** 禁止基类被继承，禁止虚函数被重写
- **explicit**、**implicit** 只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的,跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式)

# 14





# 17





# 20

