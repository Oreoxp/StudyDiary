# 对象移动

[TOC]

​		新标准的一个最主要的特性是可以移动而非拷贝对象的能力。中所见，很多情况下都会发生对象拷贝。在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。

​		如我们已经看到的，vector类是这种不必要的拷贝的一个很好的例子。在重
新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，<u>更好的方式是移动元素</u>。
​			在旧C++标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间(如string)， 进行不必要的拷贝代价非常高。类似的，在旧版本的标准库中，容器中所保存的类必须是可拷贝的。但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。

## 右值引用

​		为了支持移动操作，新标准引入了一种新的引用类型——**<u>右值引用(rvalue reference)</u>**。所谓右值引用就是必须绑定到右值的引用。<u>我们通过 && 而不是 & 来获得右值引用</u>。如我们将要看到的，右值引用有一个重要的性质一只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源“<u>**移动**</u>”到另一个对象中。

​		回忆一下，左值和右值是表达式的属性。一些表达式生成或要求左值，而另外一些则生成或要求右值。一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。

​		类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。如我们所知，

​		对于常规引用 ( 为了与右值引用区分开来，我们可以称之为**左值引用( lvalue reference)** ) ，我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。
​		右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上:

```c++
int i = 42;
int &r = i;							//正确：r引用i
int &&rr = i;						//错误：不能将一个右值引用绑定到一个左值上
int &r2 = i*42;					//错误：i*42是一个右值
const int &r3 = i*42; 	//正确：我们可以将一个const的引用绑定到一个右值上
int &&rr2 = i*42;				//正确：将rr2绑定到乘法结果上
```

​		返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。
​		返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个 const 的左值引用或者一个右值引用绑定到这类表达式上。



### 左值持久;右值短暂

​		**<u>考察左值和右值表达式的列表，两者相互区别之处就很明显了：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。</u>**

​		由于<u>右值引用只能绑定到临时对象</u>，我们得知

- 所引用的对象将要被销毁
- 该对象没有其他用户

这两个特性意味着：使用右值引用的代码可以<u>自由地</u>接管所引用的对象的资源。

小tips：找得到地址的是左值，找不到地址的是右值（字面量、临时量都没地址）。

### 变量是左值

​		变量可以看作只有一个运算对象而没有运算符的表达式，虽然我们很少这样看待变量。

​		类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。带来的结果就是，我们不能将一个右值引用绑定到一个右值引用类型的变量上，这有些令人惊讶:

```c++
int &&rrl = 42;  // 正确：字面常量是右值
int &&rr2 = rr1; // 错误：表达式rr1是左值!
```

其实有了右值表示临时对象这一观察结果，变量是左值这一特性并不令人惊讶。毕竟，变量是持久的，直至离开作用域时才被销毁。



### 标准库move函数

​		虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为 **move** 的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件 utility 中。move函数使用了我们将在后面描述的机制来返回给定对象的右值引用。

```c++
int &&rr3 = std::move(rr1) ; // ok
```

move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。 我们必须认识到，调用move就意味着承诺：<u>**除了对rr1赋值或销毁它外，我们将不再使用它**</u>。在调用move之后，我们不能对移后源对象的值做任何假设。



## 移动构造函数和移动赋值运算符

​		类似string类(及其他标准库类)，如果我们自己的类也同时支持移动和拷贝，那
么也能从中受益。为了让我们自己的类型支持移动操作，需要为其定义<u>移动构造函数</u>和<u>移动赋值运算符</u>。这两个成员类似对应的拷贝操作，但它们从给定对象<u>**“窃取”**</u>资源而不是拷贝资源。

​		类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。

​		除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态
销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源一这些资源的所有权已经归属新创建的对象。

​		作为一个例子，我们为 StrVec 类定义移动构造函数，实现从一个 StrVec 到另一个 StrVec 的元素移动而非拷贝：

```c++
Strvec::StrVec (StrVec &&s) noexcept //移动操作不应抛出任何异常
	//成员初始化器接管 s 中的资源
	: elements(s.elements), first_free(s.first_free)，cap(s.cap)
{
	//令 s 进入这样的状态————对其运行析构函数是安全的
	s.elements = s.first_free = s.cap = nullptr;
}
```

我们将简短解释noexcept (它通知标准库我们的构造函数不抛出任何异常)，但让我们先分析一下此构造函数完成什么工作。

​		与拷贝构造函数不同，<u>移动构造函数不分配任何新内存</u>；它接管给定的 StrVec中的内存。在接管内存之后，它将给定对象中的指针都置为 nullptr 。这样就完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。StrVec 的析构函数在 first_free 上调用 deallocate。 如果我们忘记了改变 s.first_free， 则销毁移后源对象就会释放掉我们刚刚移动的内存。

### 移动赋值运算符

​		移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为noexcept。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值:

```c++
StrVec &StrVec: :operator= (StrVec &&rhs) noexcept
{
		//直接检测自赋值
		if (this != &rhs) {
				free();										//释放已有元素
      
      	//从rhs接管资源：
				this->elements = rhs.elements;  
				this->first_free = rhs.first_free;
				this->cap = rhs.cap;
      
				rhs.elements = rhs.first_free = rhs.cap = nullptr;
      	//析构rhs内存
    }
		return	*this;
}
```

​		在此例中，我们直接检查 this 指针与 rhs 的地址是否相同。如果相同，右侧和左侧运算对象指向相同的对象，我们不需要做任何事情。否则，我们释放左侧运算对象所使用的内存，并接管给定对象的内存。与移动构造函数一样， 我们将 rhs 中的指针置为 nullptr。

​		我们费心地去检查自赋值情况看起来有些奇怪。毕竟，移动赋值运算符需要右侧运算对象的一个右值。我们进行检查的原因是此右值可能是 move 调用的返回结果。与其他任何赋值运算符一样，关键点是我们不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源(可能是相同的资源)。

### 移后源对象必须可析构

​		从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。我们的 StrVec 的移动操作满足这一要求， 这是通过将移后源对象的指针成员置为 nullptr 来实现的。

​		除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的。一般来说，对象有效就是指可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。另一方面，移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。

​		例如，当我们从一个标准库 string 或容器对象移动数据时，我们知道移后源对象仍然保持有效。因此，我们可以对它执行诸如 empty 或 size 这些操作。但是，我们不知道将会得到什么结果。我们可能期望一个移后源对象是空的，但这并没有保证。

​		我们的 StrVec 类的移动操作将移后源对象置于与默认初始化的对象相同的状态。因此，我们可以继续对移后源对象执行所有的 StrVec 操作，与任何其他默认初始化的对象一样。而其他内部结构更为复杂的类，可能表现出完全不同的行为。



## 右值引用和成员函数

### 右值和左值引用成员函数

​		通常,我们在一个对象上调用成员函数，而不管该对象是一个左值还是一个右值。例如:

```c++
string s1 = "a value", s2 = "another";
auto n = (s1+s2).find('a');
```

​		此例中,我们在一个  string <u>右值</u>上调用 find 成员,该 string 右值是通过连接两个string而得到的。有时，右值的使用方式可能令人惊讶:

```c++
sl+s2 = "wow!";
```

此处我们对两个 string 的连接结果一个右值， 进行了赋值。

​		在旧标准中，我们没有办法阻止这种使用方式。为了维持向后兼容性，新标准库类仍然允许向右值赋值。但是，我们可能希望在自己的类中阻止这种用法。在此情况下，我们希望<u>强制左侧运算对象(即，this 指向的对象)是一个左值</u>。

​		我们指出 this 的左值/右值属性的方式与定义 const 成员函数相同，即，在参数列表后放置一个**<u>引用限定符(reference qualifier)</u>**:

```c++
class Foo {
public:
  	//               注意这个‘&’ ↓
		Foo &operator= (const Foo&) &; //只能向可修改的左值赋值
		// Foo的其他参数
};

Foo & Foo::operator= (const Foo &rhs) &			//←注意这个&
{
		// 执行将 rhs赋予本对象所需的工作
		return *this;
}
```

**<u>引用限定符可以是&或&&，分别指出 this 可以指向一个左值或右值</u>**。类似 const限定符，引用限定符只能用于(非 static )成员函数，且必须同时出现在函数的声明和定义中。

​		对于 & 限定的函数，我们只能将它用于左值；
​		对于&&限定的函数，只能用于右值:

```c++
Foo &retFoo();		//返回一个引用; retFoo 调用是一个左值
Foo retVal();			//返回一个值; retVal调用是一个右值
Foo i, j;					//i和j是左值
i = j;						//正确:i是左值
retFoo() = j;			//正确: retFoo()返回一个左值
retVa1l() = j;		//错误: retVal()返回一个右值
i = retVal();			//正确:我们可以将一个右值作为赋值操作的右侧运算对象
```

​		一个函数可以同时用const和引用限定。在此情况下,引用限定符必须跟随在
const 限定符之后:

```c++
class Foo {
public:
		Foo someMem() & const;	 //错误: const限定符必须在前
		Foo anotherMem() const &;//正确: const限定符在前
};
```

### 重载和引用函数

​		就像一个成员函数可以根据是否有const来区分其重载版本一样，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和const来区分一个成员函数的重载版本。例如，我们将为Foo定义一一个名为data的vector成员和一个名为sorted的成员函数，sorted 返回一个Foo对象的副本，其中vector已被排序:

```c++
class Foo {
public:
		Foo sorted() &&;//可用于可改变的右值
		Foo sorted() const &;//可用于任何类型的Foo .
		// Foo的其他成员的定义
private :
		vector<int> data;
};

//本对象为右值，因此可以原址排序
Foo Foo::sorted() &&
{
		sort(data.begin()，data.end()) ;
		return *this;
}

//本对象是const或是一个左值，哪种情况我们都不能对其进行原址排序
Foo Foo::sorted() const & {
		Foo ret(*this);		 //拷贝一个副本
		sort(ret.data.begin()，ret.data.end()) ;//排序副本
		return ret;					//返回副本
}
```

当我们对一个右值执行sorted时，它可以安全地直接对data成员进行排序。对象是一个右值，意味着没有其他用户，因此我们可以改变对象。当对一个const右值或一个左值执行sorted时，我们不能改变对象，因此就需要在排序前拷贝data.

​		编译器会根据调用sorted的对象的左值/右值属性来确定使用哪个sorted版本:

```c++
retVal().sorted(); // retVal()是一个右值，调用Foo: :sorted() &&
retFoo().sorted(); // retFoo()是一个左值，调用Foo: :sorted() const &
```













