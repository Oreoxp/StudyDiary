## 跨进程边界共享内核对象



在很多时候，不同进程中运行的线程需要共享内核对象。下面罗列了一些理由。

* 利用文件映射对象，可以在同一台机器上运行的两个不冋进程之间共享数据块。

* 借助邮件槽和命名管道，在网络中的不同计算机上运行的进程可以相互发送数 据块。

* 互斥量、信号量和事件允许不同进程中的线程同步执行。例如，一个应用程序吋能 需要在完成某个任务之后，向另一个应用程序发出通知。

​        由于内核对象的句柄是与每一个进程相关的，所以执行这些任务并不轻松。不过，Microsoft 也有充分的理由需要将句柄设计成“与进程相关的”（process-relative)的。其中最電要的原 因是健壮性(可靠性)。如果把内核对象句柄设计成相对于整个系统，或者说把它们设计成 “系统级”的句柄，一个进程就可以很容易获得到“另一个进程止在使用的一个对象”的 句柄，从而对该进程造成严重破坏。之所以将句柄设计成“与进程相关的”，或者说把它 们设计成“进程级”句柄的，另一个原因是安全性。内核对象是受安全性保护的，进程在 试图操纵一个对象之前，必须先申请操纵它的权限。对象的创建者为了阻止一个未经许可 的用户“碰”自己的对象，只需拒绝该用户访问它。

​		在下一节，我们要讨论如何利用三种不同的机制来允许进程共享内核对象：使用对象句柄继承；为对象命名；复制对象句柄。









### 1.使用对象句柄继承

​		只有在进程之间有一个父 - 子关系的时候，才可以使用对象句柄继承。在这种情况下，父进程有一个或多个内核对象句柄可以使用，而且父进程决定生成一个子进程，并允许子进程访问父进程的内核对象。为了使这种继承生效，父进程必须执行几个步骤。

​		首先，当父进程创建一个内核对象时，<u>父进程必须向系统指出它希望这个对象的句柄是可以继承的</u>。有时听到别人说起 “ 对象继承 ” 这个词。但是，世界上根本没有 “ 对象继承 ” 这样的事情。Windows 支持的是 “ 对象句柄的继承 ” ；换言之，只有句柄才是可以继承的， 对象本身是不能继承的。

​		为了创建一个可继承的句柄，父进程必须分配并初始化一个 **SECURITY_ATTRIBUTES** 结构，并将这个结构的地址传给具体的 **Create** 函数。以下代码创建了一个互斥量对象，并返回其可继承的句柄：

```c++
SECURITY_ATTRIBUTES sa;
sa.nLength = sizeof(sa);
sa.IpSecurityDescriptor = NULL;
sa.blnhericHandle = TRUE; // Make the returned handle inheritable.

HANDLE hMutex * CreateMutex(&sa, FALSE, NULL);
```

​		以上代码初始化了一个 **SECURITY_ATTRIBUTES** 结构，表明对象要用默认安全性来创建，而且返回的句柄应该是可继承的。

​		接下来谈谈在进程的句柄表记录项中保存的标志。句柄表中的每个记录项都有一个指明句柄足否吋以继承的标志位。如果在创建内核对象的时候将 NULL 作为 **PSECUR1TY_ATTRIBUTES** 参数传入，则返回的句柄是不可继承的，这个标志位为 0 。 将 **blnheritHandle** 成员设为 **TRUE**，则导致这个标志位被设为 1 。

​		以表3-2的进程句柄表为例。在这个例子中，进程有权访问两个内核对象(句柄1和3)。句柄 1 足不可继承的，但句柄 3 是可以继承的。

![03包含两个有效记录项的进程句柄表](./markdowniamge/03包含两个有效记录项的进程句柄表.png)

​		为了使用对象句柄继承，下一步是由父进程生成子进程。这是通过 **CreateProcess** 函数来完成的，如下所示：

```c++
BOOL CreateProcess(
	PCTSTR pszApplicationName,
	PTSTR pszCommandLine,
	PSECURITY_ATTRIBUTES psaProcess,
	PSECURITY_ATTRIBUTES psaThread,
	BOOL blnheritHandles,
	DWORD dwCreationFlags,
	PVOID pvEnvironment,
	PCTSTR pszCurrentDirectory,
	LPSTARTUPINFO pStartupInfo,
	PPROCESS_INFORMATION pProcessInformation
);
```

​		我们将在第4章洋细讨论这个函数，现在请注意 **blnheritHandles** 参数。通常情况下，在生成一个进程时，我们要将该参数设为 FALSE 。这个值向系统表明：我们不希望子进程继承父进程句柄表中的 “ 可继承的句柄 ” 。

​		相反，如果向这个参数传递 TRUE , 子进程就会继承父进程的 “ 可继承的句柄 ” 的值。传递 TRUE 时，操作系统会创建新的子进程，但不允许子进程立即执行它的代码。当然，系统会为子进程创建一个新的、空白的进程句柄表——就像它为任何一个新进程所做的那样。 但是，由于我们传给 **CreateProcess** 函数的 **blnheritHandles** 参数的值是 **TRUE**，所以系统还会多做一件事情：它会遍历父进程的句柄表，对它的每一个记录项进行检査。凡是包含一个有效的 “ 可继承的句柄 ” 的项，都会被完整地复制到子进程的句柄表。在子进程的句柄表中，复制项的位置与它在父进程句柄表中的位置是完全一样的。这是非常重要的一个设计，因为它意味着：在父进程和子进程中，对一个内核对象进行标识的句柄值是完全一样的。

​		除了复制句柄表的记录项，系统还会递增内核对象的使用计数，因为两个进程现在都在使用这个对象。为了销毁内核对象，父进程和子进程要么都对这个对象调用 **CloseHandle**， 要么都终止运行。子进程不—定先终止——但父进程也不一定。事实上，父进程可以在 **CreateProcess** 函数返回之后立即关闭它的内核对象句柄，子进程照样可以操纵这个对象。

​		表 3-3 显示了子进程在被允许开始执行之前的句柄表。可以看出，第一项和第二项没有初始化，所以对子进程来说无效的句柄，不可以使用。但是，索引 3 标识了一个内核对象。 事实上 , 它标识的是地址 0xF0000010 处的内核对象，与父进程句柄表中的对象一样。

![03继承了父进程的可继承的句柄之后，子进程的句柄表样子](./markdowniamge/03继承了父进程的可继承的句柄之后，子进程的句柄表样子.png)

​		第 13 章将讲到，内核对象的内容被保存在内核地址空间中——系统上运行的所有进程都共享这个空间。对于32 位系统，这是 0x80000000 到 0xFFFFFFFF 之间的内存空间。对于 64 位系统，则是0x00000400’ 00000000到0xFFFFFFF’ FFFFFFFF 之间的内存空间。访问掩码与父进程中的一样，标志也是一样的。这意味着假如子进程用 **CreateProcess** 来生成它自己的子进程 ( 其父进程的孙进程 ) 并将 **blnheritHandles** 参数设为 **TRUE** 的前提下，孙进程也会继承这个内核对象句柄。在孙进程的句枘表中，继承的对象句柄将具有相同的句柄值、 相同的访问掩码以及相同的标志。内核对象的使用计数将再次递增。

​		记住，对象句柄的继承只会在生成子进程的时候发生。假如父进程后来又创建了新的内核对象，并同样将它们的句柄设为可继承的句柄。那么正在运行的子进程是不会继承这些新句柄的。

​		对象句柄继承还有一个非常奇怪的特征：子进程并不知道自己继承了任何句柄。在子进程的文档中，应指出当它从另一个进程生成时，希望获得对一个内核对象的访问权——只有在这种情况下 , 内核对象的句柄继承才是有用的。通常，父应用程序和子应用程序是由同一家公司编写的：但是，假如一家公司能在文档中说明子应用程序希望继承哪些对象句枘， 那么另一家公司就可以据此来编写一个子应用程序。

​		到目前为止，为了使子进程得到它想要的一个内核对象的句柄值，最常见的方式是将句柄值作为命令行参数传给子进程。子进程的初始化代码将解祈命令行 ( 通常是调用 _stscanf_s )， 并提取句柄值。子进程获得句柄值之后，就会拥有和父进程一样的内核对象访问权限。注意，<u>句柄继承之所以能够实现，唯一的原因就是 “ 共享的内核对象 ” 的句柄值在父进程和子进程中是完全一样的</u>。这正是父进程能将句柄值作为命令行参数来传递的原因。



​		当然，也可以使用其他进程间通信技术将继承的内核对象句柄值从父进程传入子进程:

- 一个技术是让父进程等待子进程完成初始化 ( 利用第9章讨论的 **WaitForlnputldle** 函数)；然后，父进程可以将一条消息发送或发布到由子进程中的一个线程创建的一个窗口。

* 另一种方式是让父进程向其环境块添加一个环境变量。变量的名称应该是子进程知道的一个名称，而变量的值应该是准备被子进程继承的那个内核对象的句柄值。然后，当父进程生成子进程的时候，这个子进程会继承父进程的环境变量，所以能轻松调用 **GetEnvironmentVariable** 来获得这个继承到的内核对象的句柄值。如果子进程还要生成另一个子进程，这种方式就非常不错，因为环境变量是可以反复继承的。Microsoft 知识库的一篇文章 ( 网址为 http://support.microsoft.eom/kb/l90351 ) 描述了子进程继承父控制台的特例。



### 2.改变句柄的标志

​		有时可能遇到这样一种情况：父进程创建了一个内核对象，得到了一个可继承的句柄，然后生成了两个子进程。但是，父进程只希望其中的一个子进程继承内核对象句柄。换言之, 我们冇时可能想控制哪些子进程能继承内核对象句柄。可以调用 **SetHandlelnformation** 函数来改变内核对象句枘的继承标志。如下所示： 

```C
B00L SetHandlelnformation(
	HANDLE hObject,
	DWORD dwMask,
	DWORD dwFlags
);
```

​		可以看出，这个函数有三个参数。第一个参数 **hObject** 标识了一个有效的句柄。第二个参数**dwMask**告诉函数我们想更改哪个或者哪些标志。目前，每个句柄都关联了两个标志：

```c
#define HANDLE_FLAG_INHERIT 0x00000001

#define HANDLE_FLAG_PROTECT_FR0M_CLOSE 0x00000002
```

​		如果想把每个对象的标志一次性史改完毕，可以对这两个标志执行一次按位或运算。**SetHandlelnformation** 函数的第二个参数 **dwFlags** 指出希望把标志设为什么。例如，要打开一个内核对象句柄的继承标志，可以像下面这样写：

```c
SetHandlelnformation(hObj, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);
```

要关闭这个标志，吋以像下面这样写：

```c
SetHandleInformation(hObj, HANDLE_FLAG_INHERIT, 0);
```

**HANDLE_FLAG_PROTECT_FROM_CLOSE**标志告诉系统不允许关闭句柄：

```c
SetHandlelnformation(hObj, HANDLE_FLAG_PROTECT_FROM_CLOSE,
		HANDLE_FLAG_PROTECT_FROM_CLOSE);

CloseHandle(hObj); // 会引发异常
```

​		如果在调试器下运行，一旦线程试图关闭一个受保护的句柄，**CloseHandle**就会引发一个异常。如果在调试器的控制之外，**CloseHandle**只是返回**FALSE**。几乎没有多大必要阻止句柄被关闭。但是，如果我们的一个进程会生成一个子进程，后者再生成一个孙进程，那么这个标志还是有用的。父进程可能希望孙进程依然能够从子进程那里继承对象句柄。但是，子进程可能在生成孙进程之前就关闭了那个句柄。如果发生这种情况，父进程就不能 和孙进程通信了，因为可怜的孙进程根本没有继承到内核对象(句柄)。相反，如果将句柄标记为“PROTECT FROM CLOSE”（禁止关闭)，孙进程就有更大的机会继承到指向一个有效的、活动的内核对象的句柄。

​		不过，正如前面所说的，孙进程现在只是“机会”更大一些。这种方式的不足之处在于，处于中间位置的那个子进程可以调用以下代码来关闭 **HANDLE_FLAG_PROTECT_FROM_CLOSE** 标志，然后关闭句柄：

```c
SetHandleInformation(hobj, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0);
CloseHandle(hObj)；
```

​		也就是说，父进程其实是在賭自己的子进程不会执行上述代码。但即使没有这个问题，子进程真的就会生成孙进程吗？这同样是在赌。反正都是赌，第一个赌看起来也就没有那么危险了。

​		考虑到内容的完整性，下面再来讨论一下**GetHandlelnformation**函数：

```c
BOOL GetHandlelnformation(
	HANDLE hObject,
	PDWORD pdwFlags
);
```

​		这个函数会在**pdwFlags**指向的**DWORD**中，返回指定句柄的当前标志。要检查一个句柄是否可以继承，请执行以下代码：

```c
	DWORD dwFlags;
	GetHandlelnformation(hObj, &dwFlags);
	BOOL fHandlelsInheritable = (0 != (dwFlags & HANDLE_FLAG_INHERIT));
```







### 3.为对象命名

​		跨进程边界共亨内核对象的第二个办法是为对象命名。许多(但不是全部 > 内核对象都可以进行命名。例如，以下所有函数都可以创建命名的内核对象：

```c
HANDLE CreateMutex(
	PSECURITY_ATTRIBUTES psa,
	BOOL blnitialOwner,
	PCTSTR pszName
);

HANDLE CreateEvent(
	PSECURITY_ATTRIBUTES psa,
	BOOL bManualReset,
	BOOL blnitialState,
	PCTSTR pszName
);

HANDLE CreateSemaphore(
	PSECURITY_ATTRIBUTES psa,
	LONG lInitialCount,
	LONG IMaximumCount,
	PCTSTR pszName
);

HANDLE CreateWaitableTimer( 
    PSECURITY_ATTRIBUTES psa, 
    BOOL bManualReset,
	PCTSTR pszName
);

HANDLE CreateFileMapping(
    HANDLE hFile, 
    PSECURITY_ATTRIBUTES psa, 
    DWORD flProtect,
	DWORD dwMaximumSizeHigh, 
    DWORD dwMaximumSizeLow, 
    PCTSTR pszName
);

HANDLE CreateJobObject(
	PSECURITY_ATTRIBUTES psa,
    PCTSTR pszName
);
```

​		所有这些函数的最后一个参数都是**pszName**。向此参数传入**NULL**，相当于向系统表明我们要创建一个未命名的(即匿名)内核对象。如果创建的是一个未命名对象，可以利用上一节讨论过的继承技术，或者利用下一节即将讨论的**DuplicateHandle**函数来实现进程间的对象共享。如果要根据对象名称来共享一个对象，我们必须为此对象指定一个名称。

​		如果不为**pszName**参数传递**NULL**,则应该传入一个 “ 以 0 为终止符的名称字符串 ” 的地址。这个名称可以长达**MAX_PATH**个字符(定义为260)。遗憾的是，Microsoft没有提供 任何专门的机制来保证为内核对象指定的名称是唯一的。例如，假如我们试图创建一个名为 “ JeffObj ” 的对象，那么没有任何一种机制来保证当前不存在一个名为 “ JeffObj ” 的对象。更糟的是，所有这些对象都共享同一个命名空间，即使它们的类型并不相同。例如， 以下**CreateSemaphore**函数调用肓定会返回**NULL**,因为已经有一个同名的互斥量对象了：

```c
HANDLE hMutex = CreateMutex(NULL, FALSE, TEXT("JeffObj")); 
HANDLE hSem = CreateSemaphore(NULL, 1, 1, TEXT("JeffObj"));
DWORD dwErrorCode = GetLastError();
```

​		执行上述代码之后，如果检査**dwErrorCode**的值，会发现返回的代码为6 (**ERROR_INVALID_HANDLE**)。这个错误代码当然说明不了什么问题，不过我们目前对 此无能为力。

​		知道如何命名对象之后，接着来看看如何以这种方式共享对象。假设进程 A 启动并调用以下函数：

```c
HANDLE hMutexProcessA = CreateMutex(NULL, FALSE, TEXT("JeffMutex"));
```

​		这个函数调用创建一个新的互斥暈内核对象，并将其命名为 “ JeffMutex ”。注意，在进程 A 的句柄(表)中，**hMutexProcessA**并不是一个可继承的句柄——但是，通过为对象命名来实现共亨时，是否可以继承并非一个必要条件。

​		如果后来某个进程生成了进程 B，那么进程 B 不一定要是进程 A 的子进程：它可能是从 Windows 资源管理器，也可能是其他某个应用程序生成的。**相较于使用句柄继承，利用对象的名称来共享内核对象，最大的一个优势是 “ 进程B不一定是进程A的子进程 ”** 。进程 B 开始执行时，它执行以下代码：

```c
HANDLE hMutexProcessB = CreateMutex(NULL, FALSE, TEXT("JeffMutex"));
```

​		当进程 B 调用**CreateMutex**时，系统首先会查看是否存在一个名为 “ JeffMutex ” 的内核对 象。由于确实存在这样的一个对象，所以内核接着检查对象的类型。由于试图创建一个互斥量对象，而名为 “ JeffMutex ” 的对象也是一个互斥量对象，所以系统接着执行一次安全检查，验证调用者是否拥有对该对象的完全访问权限。如果答案是肯定的，系统就会在进程 B 的句柄表中查找一个空白 id 录项，并将其初始化为指向现有的内核对象。如果对象的类型不匹配，或调用者被拒绝访问，**CreateMutex**就会失败 ( 返回 NULL ) 。

——————————————————————————————————————————————————**说明**	用于创建内核对象的函数 ( 比如 **CreateSemaphore** ) 总是返回具有完全访问权限的句柄.如果想限制一个句柄的访问权限，可以使用这些函数的扩展版本(有一个 ex 后级)，它们接受一个额外的DWORD **dwDesiredAccess**参数。例如，可以在调用 **CreateSemaphoreEx** 时使用或不使用 **SEMAPHORE_MODIFY_STATE**，从而允许或禁止对一个信号量句柄调用 **ReleaseSemaphor**。请阅读Windows SDK文档，了 解与每种内核对象的权限细节，网址是http://msdn2.microsoft.com/en-us/library/ms686670.aspx。——————————————————————————————————————————————————

​		进程 B 调用成功之后，不会实际地创建一个互斥量对象。相反，会为进程 B 分配一个新的句柄值(当然，和所有句柄值一样，这是一个相对于该进程的句柄值)，它标识了内核中的一个现有的互斥量对象。当然，由于在进程 B 的句柄表中，用一个新的记录项来引用了这个对象，所以这个互斥量对象的使用计数会被递增。在进程 A 和进程 B 都关闭这个对象的句柄之前，该对象是不会销毁的。注意，两个进程中的句柄值极有可能是不同的值。这没有什么关系。进程A用它自己的句柄值来引用那个互斥量对象，进程 B 也用它自己的句柄值来引用同一个互斥量对象。