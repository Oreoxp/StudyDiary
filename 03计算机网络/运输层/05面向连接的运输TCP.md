### 面向连接的运输：TCP

既然我们已经学习了可靠数据传输的基本原理，我们就可以转而学习TCP 了。TCP是 因特网运输层的面向连接的可靠的运输协议。我们在本节中将看到，为了提供可靠数据传 输，TCP依赖于前一节所讨论的许多基本原理，其中包括差错检测、重传、累积确认、定 时器以及用于序号和确认号的首部字段。TCP定义在RFC 793、RFC 1122、RFC 1323、 RFC 2018 以及 RFC 2581 中 D
#### 一、TCP 连接

​		TCP被称为是**面向连接的（connection-oriented)**，这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。作为TCP连接建立的一部分，连接的双方都将初始化与TCP连接相关的许多TCP状态变量（其中的许多状态变量将在本节和3. 7 节中讨论）。

![05历史事件](.\markdownImage\05历史事件.png)

​		这种TCP “连接”不是一条像在电路交换网络中的端到端TDM或FDM电路，也不是一条虚电路（参见第1章），因为其连接状态完全保留在两个端系统中。由于TCP协议只在端系统中运行，而不在中间的网络元素（路由器和链路层交换机）中运行，所以中间的网络元素不会维持TCP连接状态。事实上，中间路由器对TCP连接完全视而不见，它们看到的是数据报，而不是连接。

​		TCP连接提供的是**全双工服务（full-duplex service)**：<u>如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可在从进程B流向进程A的同时，也从进程A流向进程B</u>。TCP连接也总是**点对点（poim-to-poim)**的，即在单个发送方与单个接收方之间的连接。所谓“多播”（参见4.7节），即在一次发送操作中，从一个发送方将数据传送给多个接收方，对TCP来说这是不可能的。对于TCP而言，两台主机是一对，而3台主机则太多！

​		我们现在来看看TCP连接是怎样建立的。假设运行在某台主机上的一个进程想与另一台主机上的一个进程建立一条连接。前面讲过，发起连接的这个进程被称为<u>客户进程</u>，而另一个进程被称为<u>服务器进程</u>。该客户应用进程首先要通知客户运输层，它想与服务器上的一个进程建立一条连接。2. 7. 2节讲过，一个Python客户程序通过发出下面的命令来实现此目的。

```python
clientSocket.connect((serverName,serverPort))
```

​		其中	serverName是服务器的名宇，serverPort标识了服务器上的进程。 

​		客户上的TCP 便开始与服务器上的TCP建立一条TCP连接。我们将在本节后面更为详细地讨论连接建立的过程。现在知道下列事实就可以了 ：客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文段作为响应。前两个报文段不承载“有效载荷”，也就是不包含应用层数据；而第三个报文段可以承载有效载荷。 由于在这两台主机之间发送了 3个报文段，所以这种连接建立过程常被称为**三次握手(three- way handshake )** 。

​		一旦建立起一条TCP连接，两个应用进程之间就可以相互发送数据了。我们考虑一下从客户进程向服务器进程发送数据的情况。如2.7节中所述，客户进程通过套接字（该进程之门）传递数据流。数据一旦通过该门，它就由客户中运行的TCP控制了。如图3-28 所示，TCP将这些数据引导到该连接的**发送缓存（send buffer)**里，发送缓存是在三次握手初期设置的缓存之一。接下来TCP就会不时从发送缓存里取出一块数据。有趣的是，在 TCP规范[RFC 793]中却没提及TCP应何时实际发送缓存里的数据，只是描述为“TCP 应该在它方便的时候以报文段的形式发送数据”。TCP可从缓存中取出并放入报文段中的数据数量受限于**最大报文段长度（Maximum Segment Size，MSS)**。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的**最大传输单元（Maximum Transmission Unit, MTU)**)来设置。设置该MSS要保证一个TCP报文段（当封装在一个IP数据报中） 加上TCP/IP首部长度（通常40字节）将适合单个链路层帧。以太网和PPP链路层协议都具有1500字节的MTU，因此MSS的典型值为1460字节。已经提出了多种发现路径 MTU的方法，并基于路径MTU值设置MSS (路径MTU是指能在从源到目的地的所有链路 上发送的最大链路层帧[RFC 1191])。注意到MSS是指在报文段里应用层数据的最大长度，而不是指包括TCP首部的TCP报文段的最大长度。（该术语很容易混淆，但是我们不得不采用它，因为它已经根深蒂固了。）

​		TCP为每块客户数据配上一个TCP首部，从而形成多个**TCP报文段（TCP segment)**。 这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中。然后这些IP数据报被发送到网络中。当TCP在另一端接收到一个报文段后，该报文段的数据就被放入该 TCP连接的接收缓存中，如图3-28中所示。应用程序从此缓存中读取数据流。TCP连接的每一端都有各自的发送缓存和接收缓存。（读者可以参见http://www. awl. com/kurose-ross处 的在线流控制Java小程序，它提供了关于发送缓存和接收缓存的一个动画演示。）

![05TCP发送缓存和接收缓存](.\markdownImage\05TCP发送缓存和接收缓存.png)

从		以上讨论中我们可以看出，TCP连接的组成包括：一台主机上的缓存、变量和与进 程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。如前面 讲过的那样，在这两台主机之间的网络元素（路由器、交换机和中继器）中，没有为该连 接分配任何缓存和变量。

#### TCP报文段结构

​		简要地了解了 TCP连接后，我们研究一下TCP报文段结构。TCP报文段由首部字段和一个数据字段组成。数据字段包含一块应用数据。如前所述，MSS限制了报文段数据字段的最大长度。当TCP发送一个大文件，例如某Web页面上的一个图像时，TCP通常是将该文件划分成长度为MSS的若干块（最后一块除外，它通常小于MSS)。然而，交互式应用通常传送长度小于MSS的数据块。例如，对于像Telnet这样的远程登录应用, 其TCP报文段的数据字段经常只有一个字节。由于TCP的首部一般是20字节（比 UDP首部多12字节），所以Telnet发送的报文段也许只有21字节长。

![05TCP报文段结构](.\markdownImage\05TCP报文段结构.png)

​		图3-29显示了 TCP报文段的结构。与 UDP—样，首部包括**源端口号**和**目的端口号**，它被用于多路复用/分解来自或送到上 层应用的数据。另外，同UDP—样，TCP 首部也包括**检验和字段（checksum field)**。 TCP报文段首部还包含下列字段：

- <u>32比特</u>的**序号字段（sequence number field)**和<u>32比特</u>的**确认号字段（acknowledgment number field)** 。 这些字段被 TCP 发送方和接收方用来实现可靠数据传输服务，讨论见后。
- <u>6比特</u>的**接收窗口字段（receive window field)**，该字段用于流量控制。我们很快就会看到，该字段用于指示接收方愿意接受的字节数量。

- <u>4比特</u>的**首部长度字段（header length field)**，该字段指示了<u>以32比特的字为单位</u>的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的。（通常, 选项字段为空，所以TCP首部的典型长度就是20字节。）
- <u>可选与变长</u>的**选项字段（options field)**,该字段用于发送方与接收方协商最大报文段长度（MSS)时，或在高速网络环境下用作窗口调节因子时使用。首部字段中还定义了一个时间戳选项。可参见RFC 854和RFC 1323 了解其他细节。
- <u>6比特</u>的**标志字段（flag field)**。**ACK比特**用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认。**RST**、**SYN**和**FIN**比特用于连接建立和拆除，我们将在本节后面讨论该问题。当**PSH**比特被设置的时候，就指示接收方应立即将数据交给上层。最后，**URG**比特用来指示报文段里存在着被发 送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由16比特的**紧急数据指针字段**指出。当紧急数据存在并给出指向紧急数据尾的指针的时候，TCP 必须通知接收端的上层实体。（在实践中，PSH、URG和紧急数据指针并没有使 用。为了完整性起见，我们才提到这些字段。）

##### 1.序号和确认号

​		TCP报文段<u>首部</u>中两个最重要的字段是序号字段和确认号字段。这两个字段是TCP可靠传输服务的关键部分。但是在讨论这两个字段是如何用于提供可靠数据传输之前，我们首先来解释一下TCP在这两个字段中究竟放置了什么。

​		TCP把数据看成一个无结构的、有序的字节流。我们从TCP对序号的使用上可以看出这一点，因为序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。 **—个报文段的序号（sequence number for a segment)**因此是该报文段首字节的字节流编号。 举例来说，假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流。主机A中的TCP将隐式地对数据流中的每一个字节编号。假定数据流由一个包含500 000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。如图3-30 所示，该TCP将为该数据流构建500个报文段。给第一个报文段分配序号0,第二个报 段分配序号1000,第三个报文段分配序号2000,以此类推。每一个序号被填入到相应TCP 报文段首部的序号字段中。

![05文件数据划分成TCP报文段](.\markdownImage\05文件数据划分成TCP报文段.png)

​		现在我们考虑一下确认号。确认号要比序号难处理一些。前面讲过，TCP是全双工的，因此主机A在向主机B发送数据的同时，也许也接收来自主机B的数据（都是同一条TCP连接的一部分）。从主机B到达的每个报文段中都有一个序号用于从B流向A的数据。<u>主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。</u>看一些例子有助于理解实际发生的事情。假设主机A已收到了来自主机B的编号为0 ~535的所有字节，同时假设它打算发送一个报文段给主机B。主机A等待主机B的数据流中字节536及之后的所有字节。所以主机A就会在它发往主机B的报文段的确认号字段中填上536。

​		再举一个例子，假设主机A已收到一个来自主机B的包含字节0~535的报文段，以及另一个包含字节900-1000的报文段。由于某种原因，主机A还没有收到字节536 ~899 的报文段。在这个例子中，主机A为了重新构建主机B的数据流，仍在等待字节536 (和其后的字节）。因此，A到B的下一个报文段将在确认号字段中包含536。因为TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供**累积确认（cumulative acknowledgment)** 。

​		最后一个例子也会引发一个重要而微妙的问题。主机A在收到第二个报文段（字节 536 ~899)之前收到第三个报文段（字节900 ~ 1000)。因此，第三个报文段失序到达。 该微妙的问题是：当主机在一条TCP连接中收到失序报文段时该怎么办？有趣的是，TCP RFC并没有为此明确规定任何规则，而是把这一问题留给实现TCP的编程人员去处理。他 们有两个基本的选择：

①接收方立即丢弃失序报文段（如前所述，这可以简化接收方的设计）；

②接收方保留失序的字节，并等待缺少的字节以填补该间隔。显然，后一种选择对网络带宽而言更为有效，是实践中采用的方法。

​		在图3-30中，我们假设初始序号为0。事实上，一条TCP连接的双方均可随机地选择初始序号。这样做可以减少将那些仍在网络中存在的来自两台主机之间先前已终止的连接的报文段，误认为是后来这两台主机之间新建连接所产生的有效报文段的可能性（它碰巧与旧连接使用了相同的端口号）[Sunshine 1978]。

##### 2.Telnet :序号和确认号的一个学习案例

​		Telnet由RFC 854定义，它现在是一个用于远程登录的流行应用层协议。它运行在TCP之上，被设计成可在任意一对主机之间工作。Telnet与我们第2章讨论的批量数据传输应用不同，它是一个交互式应用。我们在此讨论一个Telnel例子，因为该例子很好地阐述TCP的序号与确认号。我们注意到许多用户现在更愿意采用SSH协议而不是Telnet,因为在Telnet连接中发送的数据（包括口令！）是没有加密的，使得Telnet易于受到窃听攻击（如在8. 7节中讨论的那样）。

​		假设主机A发起一个与主机B的Telnet会话。因为是主机A发起该会话，因此它被标记为客户，而主机B被标记为服务器。（在客户端的）用户键入的每个字符都会被发送至远程主机；远程主机将回送每个字符的副本给客户，并将这些字符显示在Telnet用户的屏幕上。这种“回显”（echo back)用于确保由Telnet用户发送的字符已经被远程主机收到并在远程站点上得到处理。因此，在从用户击键到字符被显示在用户屏幕上这段时间内，每个字符在网络中传输了两次。

​		现在假设用户输入了一个字符‘C’，然后喝起了咖啡。我们考察一下在客户与服务器之间发送的TCP报文段。如图3-31所示，假设客户和服务器的起始序号分别是42和 79。前面讲过，一个报文段的序号就是该报文段数据字段首字节的序号。因此，客户发送 的第一个报文段的序号为42,服务器发送的第一个报文段的序号为79。前面讲过，确认 号就是主机正在等待的数据的下一个字节序号。在TCP连接建立后但没有发送任何数据之 前，该客户等待字节79,而该服务器等待字节42。