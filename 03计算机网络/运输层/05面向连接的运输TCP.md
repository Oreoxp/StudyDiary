### 面向连接的运输：TCP

既然我们已经学习了可靠数据传输的基本原理，我们就可以转而学习TCP 了。TCP是 因特网运输层的面向连接的可靠的运输协议。我们在本节中将看到，为了提供可靠数据传 输，TCP依赖于前一节所讨论的许多基本原理，其中包括差错检测、重传、累积确认、定 时器以及用于序号和确认号的首部字段。TCP定义在RFC 793、RFC 1122、RFC 1323、 RFC 2018 以及 RFC 2581 中 D
#### 一、TCP 连接

​		TCP被称为是**面向连接的（connection-oriented)**，这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。作为TCP连接建立的一部分，连接的双方都将初始化与TCP连接相关的许多TCP状态变量（其中的许多状态变量将在本节和3. 7 节中讨论）。

![05历史事件](.\markdownImage\05历史事件.png)

​		这种TCP “连接”不是一条像在电路交换网络中的端到端TDM或FDM电路，也不是一条虚电路（参见第1章），因为其连接状态完全保留在两个端系统中。由于TCP协议只在端系统中运行，而不在中间的网络元素（路由器和链路层交换机）中运行，所以中间的网络元素不会维持TCP连接状态。事实上，中间路由器对TCP连接完全视而不见，它们看到的是数据报，而不是连接。

​		TCP连接提供的是**全双工服务（full-duplex service)**：<u>如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可在从进程B流向进程A的同时，也从进程A流向进程B</u>。TCP连接也总是**点对点（poim-to-poim)**的，即在单个发送方与单个接收方之间的连接。所谓“多播”（参见4.7节），即在一次发送操作中，从一个发送方将数据传送给多个接收方，对TCP来说这是不可能的。对于TCP而言，两台主机是一对，而3台主机则太多！

​		我们现在来看看TCP连接是怎样建立的。假设运行在某台主机上的一个进程想与另一台主机上的一个进程建立一条连接。前面讲过，发起连接的这个进程被称为<u>客户进程</u>，而另一个进程被称为<u>服务器进程</u>。该客户应用进程首先要通知客户运输层，它想与服务器上的一个进程建立一条连接。2. 7. 2节讲过，一个Python客户程序通过发出下面的命令来实现此目的。

```python
clientSocket.connect((serverName,serverPort))
```

​		其中	serverName是服务器的名宇，serverPort标识了服务器上的进程。 

​		客户上的TCP 便开始与服务器上的TCP建立一条TCP连接。我们将在本节后面更为详细地讨论连接建立的过程。现在知道下列事实就可以了 ：客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文段作为响应。前两个报文段不承载“有效载荷”，也就是不包含应用层数据；而第三个报文段可以承载有效载荷。 由于在这两台主机之间发送了 3个报文段，所以这种连接建立过程常被称为**三次握手(three- way handshake )** 。

​		一旦建立起一条TCP连接，两个应用进程之间就可以相互发送数据了。我们考虑一下从客户进程向服务器进程发送数据的情况。如2.7节中所述，客户进程通过套接字（该进程之门）传递数据流。数据一旦通过该门，它就由客户中运行的TCP控制了。如图3-28 所示，TCP将这些数据引导到该连接的**发送缓存（send buffer)**里，发送缓存是在三次握手初期设置的缓存之一。接下来TCP就会不时从发送缓存里取出一块数据。有趣的是，在 TCP规范[RFC 793]中却没提及TCP应何时实际发送缓存里的数据，只是描述为“TCP 应该在它方便的时候以报文段的形式发送数据”。TCP可从缓存中取出并放入报文段中的数据数量受限于**最大报文段长度（Maximum Segment Size，MSS)**。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的**最大传输单元（Maximum Transmission Unit, MTU)**)来设置。设置该MSS要保证一个TCP报文段（当封装在一个IP数据报中） 加上TCP/IP首部长度（通常40字节）将适合单个链路层帧。以太网和PPP链路层协议都具有1500字节的MTU，因此MSS的典型值为1460字节。已经提出了多种发现路径 MTU的方法，并基于路径MTU值设置MSS (路径MTU是指能在从源到目的地的所有链路 上发送的最大链路层帧[RFC 1191])。注意到MSS是指在报文段里应用层数据的最大长度，而不是指包括TCP首部的TCP报文段的最大长度。（该术语很容易混淆，但是我们不得不采用它，因为它已经根深蒂固了。）

​		TCP为每块客户数据配上一个TCP首部，从而形成多个**TCP报文段（TCP segment)**。 这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中。然后这些IP数据报被发送到网络中。当TCP在另一端接收到一个报文段后，该报文段的数据就被放入该 TCP连接的接收缓存中，如图3-28中所示。应用程序从此缓存中读取数据流。TCP连接的每一端都有各自的发送缓存和接收缓存。（读者可以参见http://www. awl. com/kurose-ross处 的在线流控制Java小程序，它提供了关于发送缓存和接收缓存的一个动画演示。）

![05TCP发送缓存和接收缓存](.\markdownImage\05TCP发送缓存和接收缓存.png)

从		以上讨论中我们可以看出，TCP连接的组成包括：一台主机上的缓存、变量和与进 程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。如前面 讲过的那样，在这两台主机之间的网络元素（路由器、交换机和中继器）中，没有为该连 接分配任何缓存和变量。

#### TCP报文段结构

​		简要地了解了 TCP连接后，我们研究一下TCP报文段结构。TCP报文段由首部字段和一个数据字段组成。数据字段包含一块应用数据。如前所述，MSS限制了报文段数据字段的最大长度。当TCP发送一个大文件，例如某Web页面上的一个图像时，TCP通常是将该文件划分成长度为MSS的若干块（最后一块除外，它通常小于MSS)。然而，交互式应用通常传送长度小于MSS的数据块。例如，对于像Telnet这样的远程登录应用, 其TCP报文段的数据字段经常只有一个字节。由于TCP的首部一般是20字节（比 UDP首部多12字节），所以Telnet发送的报文段也许只有21字节长。

![05TCP报文段结构](.\markdownImage\05TCP报文段结构.png)

​		图3-29显示了 TCP报文段的结构。与 UDP—样，首部包括**源端口号**和**目的端口号**，它被用于多路复用/分解来自或送到上 层应用的数据。另外，同UDP—样，TCP 首部也包括**检验和字段（checksum field)**。 TCP报文段首部还包含下列字段：

- <u>32比特</u>的**序号字段（sequence number field)**和<u>32比特</u>的**确认号字段（acknowledgment number field)** 。 这些字段被 TCP 发送方和接收方用来实现可靠数据传输服务，讨论见后。
- <u>6比特</u>的**接收窗口字段（receive window field)**，该字段用于流量控制。我们很快就会看到，该字段用于指示接收方愿意接受的字节数量。

- <u>4比特</u>的**首部长度字段（header length field)**，该字段指示了<u>以32比特的字为单位</u>的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的。（通常, 选项字段为空，所以TCP首部的典型长度就是20字节。）
- <u>可选与变长</u>的**选项字段（options field)**,该字段用于发送方与接收方协商最大报文段长度（MSS)时，或在高速网络环境下用作窗口调节因子时使用。首部字段中还定义了一个时间戳选项。可参见RFC 854和RFC 1323 了解其他细节。
- <u>6比特</u>的**标志字段（flag field)**。**ACK比特**用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认。**RST**、**SYN**和**FIN**比特用于连接建立和拆除，我们将在本节后面讨论该问题。当**PSH**比特被设置的时候，就指示接收方应立即将数据交给上层。最后，**URG**比特用来指示报文段里存在着被发 送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由16比特的**紧急数据指针字段**指出。当紧急数据存在并给出指向紧急数据尾的指针的时候，TCP 必须通知接收端的上层实体。（在实践中，PSH、URG和紧急数据指针并没有使 用。为了完整性起见，我们才提到这些字段。）

##### 1.序号和确认号

​		TCP报文段<u>首部</u>中两个最重要的字段是序号字段和确认号字段。这两个字段是TCP可靠传输服务的关键部分。但是在讨论这两个字段是如何用于提供可靠数据传输之前，我们首先来解释一下TCP在这两个字段中究竟放置了什么。

​		TCP把数据看成一个无结构的、有序的字节流。我们从TCP对序号的使用上可以看出这一点，因为序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。 **—个报文段的序号（sequence number for a segment)**因此是该报文段首字节的字节流编号。 举例来说，假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流。主机A中的TCP将隐式地对数据流中的每一个字节编号。假定数据流由一个包含500 000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。如图3-30 所示，该TCP将为该数据流构建500个报文段。给第一个报文段分配序号0,第二个报 段分配序号1000,第三个报文段分配序号2000,以此类推。每一个序号被填入到相应TCP 报文段首部的序号字段中。

![05文件数据划分成TCP报文段](.\markdownImage\05文件数据划分成TCP报文段.png)

​		现在我们考虑一下确认号。确认号要比序号难处理一些。前面讲过，TCP是全双工的，因此主机A在向主机B发送数据的同时，也许也接收来自主机B的数据（都是同一条TCP连接的一部分）。从主机B到达的每个报文段中都有一个序号用于从B流向A的数据。<u>主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。</u>看一些例子有助于理解实际发生的事情。假设主机A已收到了来自主机B的编号为0 ~535的所有字节，同时假设它打算发送一个报文段给主机B。主机A等待主机B的数据流中字节536及之后的所有字节。所以主机A就会在它发往主机B的报文段的确认号字段中填上536。

​		再举一个例子，假设主机A已收到一个来自主机B的包含字节0~535的报文段，以及另一个包含字节900-1000的报文段。由于某种原因，主机A还没有收到字节536 ~899 的报文段。在这个例子中，主机A为了重新构建主机B的数据流，仍在等待字节536 (和其后的字节）。因此，A到B的下一个报文段将在确认号字段中包含536。因为TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供**累积确认（cumulative acknowledgment)** 。

​		最后一个例子也会引发一个重要而微妙的问题。主机A在收到第二个报文段（字节 536 ~899)之前收到第三个报文段（字节900 ~ 1000)。因此，第三个报文段失序到达。 该微妙的问题是：当主机在一条TCP连接中收到失序报文段时该怎么办？有趣的是，TCP RFC并没有为此明确规定任何规则，而是把这一问题留给实现TCP的编程人员去处理。他 们有两个基本的选择：

①接收方立即丢弃失序报文段（如前所述，这可以简化接收方的设计）；

②接收方保留失序的字节，并等待缺少的字节以填补该间隔。显然，后一种选择对网络带宽而言更为有效，是实践中采用的方法。

​		在图3-30中，我们假设初始序号为0。事实上，一条TCP连接的双方均可随机地选择初始序号。这样做可以减少将那些仍在网络中存在的来自两台主机之间先前已终止的连接的报文段，误认为是后来这两台主机之间新建连接所产生的有效报文段的可能性（它碰巧与旧连接使用了相同的端口号）[Sunshine 1978]。

##### 2.Telnet :序号和确认号的一个学习案例

​		Telnet由RFC 854定义，它现在是一个用于远程登录的流行应用层协议。它运行在TCP之上，被设计成可在任意一对主机之间工作。Telnet与我们第2章讨论的批量数据传输应用不同，它是一个交互式应用。我们在此讨论一个Telnel例子，因为该例子很好地阐述TCP的序号与确认号。我们注意到许多用户现在更愿意采用SSH协议而不是Telnet,因为在Telnet连接中发送的数据（包括口令！）是没有加密的，使得Telnet易于受到窃听攻击（如在8. 7节中讨论的那样）。

​		假设主机A发起一个与主机B的Telnet会话。因为是主机A发起该会话，因此它被标记为客户，而主机B被标记为服务器。（在客户端的）用户键入的每个字符都会被发送至远程主机；远程主机将回送每个字符的副本给客户，并将这些字符显示在Telnet用户的屏幕上。这种“回显”（echo back)用于确保由Telnet用户发送的字符已经被远程主机收到并在远程站点上得到处理。因此，在从用户击键到字符被显示在用户屏幕上这段时间内，每个字符在网络中传输了两次。

​		现在假设用户输入了一个字符‘C’，然后喝起了咖啡。我们考察一下在客户与服务器之间发送的TCP报文段。如图3-31所示，假设客户和服务器的起始序号分别是42和 79。前面讲过，一个报文段的序号就是该报文段数据字段首字节的序号。因此，客户发送的第一个报文段的序号为42,服务器发送的第一个报文段的序号为79。前面讲过，确认号就是主机正在等待的数据的下一个字节序号。在TCP连接建立后但没有发送任何数据之前，该客户等待字节79,而该服务器等待字节42。

![05一个经TCP的简单telent应用的确认号和序号](.\markdownImage\05一个经TCP的简单telent应用的确认号和序号.png)

​		如图3-31中所示，共发送3个报文段。第一个报文段是由客户发往服务器，在它的数据字段里包含一字节的字符‘C’的ASCII码。如我们刚讲到的那样，第一个报文段的序号字段里是42。另外，由于客户还没有接收到来自服务器的任何数据，因此该第一个报文段中的确认号字段中是79。

​		第二个报文段是由服务器发往客户。它有两个目的：首先它是为该服务器所收到数据提供一个确认。通过在确认号字段中填人43,服务器告诉客户它已经成功地收到字节42 及以前的所有字节，现在正等待着字节43的出现。该报文段的第二个目的是回显字符 ‘C’。因此，在第二个报文段的数据字段里填人的是字符‘C’的ASCII码。第二个报文段的序号为79,它是该TCP连接上从服务器到客户的数据流的起始序号，这也正是服务器要发送的第一个字节的数据。值得注意的是，对客户到服务器的数据的确认被装载在一 个承载服务器到客户的数据的报文段中；这种确认被称为是被**梢带（piggybacked)**在服务器到客户的数据报文段中的。

​		第三个报文段是从客户发往服务器的。它的唯一目的是确认已从服务器收到的数据。 (前面讲过，第二个报文段中包含的数据是字符‘C’，是从服务器到客户的。）该报文段的数据字段为空（即确认信息没有被任何从客户到服务器的数据所捎带）。该报文段的确认号字段填入的是80,因为客户已经收到了字节流中序号为79及以前的字节，它现在正 等待着字节80的出现。你可能认为这有点奇怪，即使该报文段里没有数据还仍有序号。 这是因为TCP存在序号字段，报文段需要填人某个序号。

#### 往返时间的估计与超时

​		TCP如同前面3. 4节所讲的rdt协议一样，它采用超时/重传机制来处理报文段的丢失问题。尽管这在概念上简单，但是当在如TCP这样的实际协议中实现超时/重传机制时还是会产生许多微妙的问题。也许最明显的一个问题就是超时间隔长度的设置。显然，超时间隔必须大于该连接的往返时间（RTT)，即从一个报文段发出到它被确认的时间。否则会造成不必要的重传。但是这个时间间隔到底应该是多大呢？刚开始时应如何估计往返时间呢？是否应该为所有未确认的报文段各设一个定时器？问题如此之多！我们在本节中的 讨论基于[Jacobson 1988]中有关TCP的工作以及IETF关于管理TCP定时器的建议 [RFC 6298]。

##### 1.估计往返时间

​		我们开始学习TCP定时器的管理问题，要考虑一下TCP是如何估计发送方与接收方之间往返时间的。这是通过如下方法完成的。报文段的样本RTT (表示为SampleRTT)就是从某报文段被发出（即交给IP)到对该报文段的确认被收到之间的时间量。大多数TCP 的实现仅在某个时刻做一次SampleRTT测量，而不是为每个发送的报文段测量一个SampleRTT。这就是说，在任意时刻，仅为一个已发送的但目前尚未被确认的报文段估计SampleRTT，从而产生一个接近每个RTT的新SampleRTT值。另外，TCP决不为已被重传的报文段计算SampleRTT;它仅为传输一次的报文段测量SampleRTT [Kan 1987]。（本章后面的一个习题请你考虑一下为什么要这么做。）

​		显然，由于路由器的拥塞和端系统负载的变化，这些报文段的SampleRTT值会随之波动。由于这种波动，任何给定的SampleRTT值也许都是非典型的。因此，为了估计一个典型的RTT，自然要采取某种对SampleRTT取平均的办法。TCP维持一个SampleRTT均值 (称为EstimatedRTT)。一旦获得一个新SampleRTT时，TCP就会根据下列公式来更新EstimatedRTT ：

​		EstimatedRTT = (1 - α) • EstimatedRTT +α • SampleRTT

​		 上面的公式是以编程语言的语句方式给出的，即EstimatecmTT的新值是由以前的EstimatedRTT值与SampleRTT新值加权组合而成的。在[RFC 6298]中给出的a参考值是 α=0. 125 (即1/8)，这时上面的公式变为：

​		EstimatedRTT =0. 875 * EstimatedRTT +0. 125 • SampleRTT 

​		值得注意的是，EstimatedRTT是一个SampleRTT值的加权平均值。如在本章后面习题中讨论的那样，这个加权平均对最近的样本赋予的权值要大于对老样本赋予的权值。这是很自然的，因为越近的样本越能更好地反映网络的当前拥塞情况。从统计学观点讲，这种平均被称为**指数加权移动平均（Exponential Weighted Moving Average，EWMA)**。在EWMA 中的“指数” 一词看起来是指一个给定的SampleRTT的权值在更新的过程中呈指数型快速衰减。在课后习题中，将要求你推导出EstimatedRTT的指数表达形式。

​		图3-32显示了当a = 1/8时，在gaia.cs. umass. edu (在美国马萨诸塞州的Amherst)与 fantasia, eurecom. fr (在法国南部）之间的一条 TCP 连接上的 SampleRTT 值与 EstimatedRTT 值。显然，SampleRTT的变化在计算EstimatedRTT的过程中趋于平缓。

​		除了估算RTT外，测量RTT的变化也是有价值的。[RFC 6298]定义了 RTT偏差 DevRTT,用于估算SampleRTT —般会偏离EstimatedRTT的程度：

​		DevRTT = (1 -β) • DevRTT +β • | SampleRTT - EstimatedRTT |

​	注意到 DevRTT 是一个 SampleRTT 与 EstimatedRTT 之间差值的 EWMA。如果 SampleRTT值波动较小，那么DevRTT的值就会很小；另一方面，如果波动很大，那么DevRTT的值就会很大。β的推荐值为0. 25。

![05RTT样本和RTT估计](.\markdownImage\05RTT样本和RTT估计.png)

##### 2.设置和管理重传超时间隔

​		假设已经给出了 EstimatedRTT值和DevRTT值，那么TCP超时间隔应该用什么值呢? 很明显，超时间隔应该大于等于EstimatedRTT,否则，将造成不必要的重传。但是超时间隔也不应该比EstimaledRTT大太多，否则当报文段丢失时，TCP不能很快地重传该报文段，导致数据传输时延大。因此要求将超时间隔设为EstimatedRTT加上一定余量。当 SampleRTT值波动较大时，这个余量应该大些；当波动较小时，这个余量应该小些。因此，DevRTT值应该在这里发挥作用了。在TCP的确定重传超时间隔的方法中，所有这些 因素都考虑到了：

​		Timeoutlnterval = EstimatedRTT +4 • DevRTT

​		推荐的初始Timeoutlnterval值为1秒[RFC 6298]。同样，当出现超时后，Timeoutlnterval值将加倍，以免即将被确认的后继报文段过早出现超时。不管怎样，一旦报文段收到并更新EstimatedRTT后，Timeoutlnterval就又使用上述公式计算了 。
![05实践原则](.\markdownImage\05实践原则.png)

![05实践原则2](.\markdownImage\05实践原则2.png)

#### 可靠数据传输

​		前面讲过，因特网的网络层服务（IP服务）是不可靠的。IP不保证数据报的交付， 不保证数据报的按序交付，也不保证数据报中数据的完整性。对于IP服务，数据报能够溢出路由器缓存而永远不能到达目的地，数据报也可能是乱序到达，而且数据报中的比特可能损坏（由0变为1或者相反）。由于运输层报文段是被IP数据报携带着在网络中传输的，所以运输层的报文段也会遇到这些问题。

​		TCP在IP不可靠的尽力而为服务之上创建了一种**可靠数据传输服务（reliable data transfer service)**。TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隔、非冗余和按序的数据流；即该字节流与连接的另一方端系统发送出的字节流是完全相同。TCP提供可靠数据传输的方法涉及我们在3. 4节中所学的许多原理。

​		在我们前面研发可靠数据传输技术时，曾假定每一个已发送但未被确认的报文段都与一个定时器相关联，这在概念上是最简单的。虽然这在理论上很好，但定时器的管理却需要相当大的开销。因此，推荐的定时器管理过程[RFC 6298]仅使用单一的重传定时器, 即使有多个已发送但还未被确认的报文段。在本节中描述的TCP协议遵循了这种单一定时器的推荐。

​		我们将以两个递增的步骤来讨论TCP是如何提供可靠数据传输的。我们先给出一个TCP发送方的髙度简化的描述，该发送方只用超时来恢复报文段的丢失；然后再给出一个更全面的描述，该描述中除了使用超时机制外，还使用冗余确认技术。在接下来的讨论中，我们假定数据仅向一个方向发送，即从主机A到主机B,且主机A在发送一个大文件。

​		图3-33给出了一个TCP发送方高度简化的描述。我们看到在TCP发送方有3个与发送和重传有关的主要事件：<u>从上层应用程序接收数据；定时器超时；收到ACK</u>。

​		一旦第一个主要事件发生，TCP从应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP。注意到每一个报文段都包含一个序号，如3. 5. 2节所讲的那样，这个序号就是该报文段第一个数据字节的字节流编号。还要注意到如果定时器还没有为某些其他报文段而运行，则当报文段被传给IP时，TCP就启动该定时器。（将定时器想象为与最早的未被确认的报文段相关联是有帮助的。）该定时器的过期间隔是Timeoutinlerval,它是由3.5.3节 中所描述的EstimatedRTT和DevRTT计算得出的。

​		第二个主要事件是超时。 TCP通过重传引起超时的报文段来响应超时事件。然后TCP 重启定时器。

​		TCP发送方必须处理的第三个主要事件是一个来自接收方的确认报文段（ACK)的到达（更确切地说是一个包含了有效ACK字段值的报文段）。当该事件发生时，TCP将ACK 的值y与它的变量SendBase进行比较。TCP状态变量SendBase是最早未被确认的字节的序号。（因此SendBase-1是指接收方已正确按序接收到的数据的最后一个字节的序号。）如前面指出的那样，TCP采用累积确认，所以y确认了字节编号在y之前的所有字节都已经收到。如果y>SendBase,则该ACK是在确认一个或多个先前未被确认的报文段。因此发送方更新它的SendBase变量；如果当前有未被确认的报文段，TCP还要重新启动定时器。

![05简化TCP发送方](.\markdownImage\05简化TCP发送方.png)

##### 1.一些包趣的情况

​		我们刚刚描述了一个关于TCP如何提供可靠数据传输的髙度简化的版本。但即使这种高度简化的版本，仍然存在着许多微妙之处。为了较好地感受该协议的工作过程，我们来看几种简单情况。图3-34描述了第一种情况，主机A向主机B发送一个报文段。假设该报文段的序号是92,而且包含8字节数据。在发出该报文段之后，主机A等待一个来自主机B的确认号为100的报文段。虽然A发出的报文段在主机B上被收到，但从主机B 发往主机A的确认报文丢失了。在这种情况下，超时事件就会发生，主机A会重传相同的报文段。当然，当主机B收到该重传的报文段时，它将通过序号发现该报文段包含了早已收到的数据。因此，主机B中的TCP将丢弃该重传的报文段中的这些字节。

​		在第二种情况中，如图3-35所示，主机A连续发回了两个报文段。第一个报文段序号是92,包含8字节数据；第二个报文段序号是100,包含20字节数据。假设两个报文段都完好无损地到达主机B,并且主机B为每一个报文段分别发送一个确认。第一个确认报文的确认号是100,第二个确认报文的确认号是120。现在假设在超时之前这两个报文段中没有一个确认报文到达主机A。当超时事件发生时，主机A重传序号92的第一个报文段，并重启定时器。只要第二个报文段的ACK在新的超时发生以前到达，则第二个报文段将不会被重传。

![05重传](.\markdownImage\05重传.png)

​		在第三种也是最后一种情况中，假设主机A与在第二种情况中完全一样，发送两个报文段。第一个报文段的确认报文在网络丢失，但在超时事件发生之前主机A收到一个确认号为120的确认报文。主机A因而知道主机B已经收到了序号为119及之前的所有字节; 所以主机A不会重传这两个报文段中的任何 一个。这种情况在图3-36中进行了图示。

![05累计确认避免了第一个报文段的重传](.\markdownImage\05累计确认避免了第一个报文段的重传.png)

##### 2.超时间隔加倍

​		我们现在讨论一下在大多数TCP实现中所做的一些修改。首先关注的是在定时器时限过期后超时间隔的长度。在这种修改中， 每当超时事件发生时，如前所述，TCP重传具有最小序号的还未被确认的报文段。只是每次TCP重传时都会将下一次的超时间隔设为先前值的两倍，而不是用从EstimatedRTT 和DevRTT推算出的值（如在3.5.3节中所 描述的）。例如，假设当定时器第一次过期时，与最早的未被确认的报文段相关联的 TimeoutInlerval是0.75秒。TCP就会重传该报文段，并把新的过期时间设置为1.5秒。如果1.5秒后定时器又过期了，则TCP将再次重传该报文段，并把过期时间设置为3.0秒。因此，**超时间隔在每次重传后会呈指数型增长**。然而，每当定时器在另两个事件（即收到上层应用的数据和收到ACK)中的任意一 个启动时，Timeoutlnterval由最近的EstimatedRTT值与DevRTT值推算得到。

​		这种修改提供了一个形式受限的拥塞控制。（更复杂的TCP拥塞控制形式将在3. 7节 中学习。）定时器过期很可能是由网络拥塞引起的，即太多的分组到达源与目的地之间路径上的一台（或多台）路由器的队列中，造成分组丢失或长时间的排队时延。在拥塞的时候，如果源持续重传分组，会使拥塞更加严重。相反，TCP使用更文雅的方式，每个发送方的重传都是经过越来越长的时间间隔后进行的。当我们在第5章学习CSMA/CD时，将 看到以太网采用了类似的思路。

##### 3.快速重传

​		超时触发重传存在的问题之一是超时周期可能相对较长。当一个报文段丢失时，这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端时延。幸运的是，发送方通常可在超时事件发生之前通过注意所谓冗余ACK来较好地检测到丢包情况。**冗余ACK (duplicate ACK)**就是再次确认某个报文段的ACK，而发送方先前已经收到对该报文段的确认。要理解发送方对冗余ACK的响应，我们必须首先看一下接收方为什么会发送冗余 ACK。表3-2总结了 TCP接收方的ACK生成策略[RFC 5681 ]。当TCP接收方收到一个具有这样序号的报文段时，即其序号大于下一个所期望的、按序的报文段，它检测到了数据流中的一个间隔，这就是说有报文段丢失。这个间隔可能是由于在网络中报文段丢失或重新排序造成的。因为TCP不使用否定确认，所以接收方不能向发送方发回一个显式的否定 确认。相反，它只是对已经接收到的最后一个按序字节数据进行重复确认（即产生一个冗余ACK)即可。（注意到在表3-2中允许接收方不丢弃失序报文段。）

![05产生TCP ACK的建议](.\markdownImage\05产生TCP ACK的建议.png)

​		因为发送方经常一个接一个地发送大量的报文段，如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK。如果TCP发送方接收到对相同数据的3个冗余ACK,它把这当作一种指示，说明跟在这个已被确认过3次的报文段之后的报文段已经丢失。（在课后习题中，我们将考虑为什么发送方等待3个冗余ACK，而不是仅仅等待一个冗余 ACK。）一旦收到3个冗余ACK, TCP就执行**快速重传（fast retransmit)** [RFC 5681],即在该报文段的定时器过期之前重传丢失的报文段。对于采用快速重传的TCP,可用下列代码片段代替图3-33中的ACK收到事件：

```
event: ACK received, with ACK field value of y 
		if (y > SendBase) {
			SendBase=y
			if (there are currently any not yet acknowledged segments) 
				start timer
		} else { /* a duplicate ACK for already ACKed segment */
			increment number of duplicate ACKs 
				received for y
			if (number of duplicate ACKS received for y==3)
				/* TCP fast retransmit */
				resend segment with sequence number y
		}
		break;
```

​		前面讲过，当在如TCP这样一个实际协议中实现超时/重传机制时，会产生许多微妙的问题。上面的过程是在超过20年的TCP定时器使用经验的基础上演化而来的， 读者应当理解实际情况确实是这样的。

##### 4.是回退N步还是选择重传

![05快速重传](.\markdownImage\05快速重传.png)

​		考虑下面这个问题来结束有关TCP差错恢复机制的学习：TCP是一个GBN协议还是一个SR协议？前面讲过，TCP确认是累积式的，正确接收但失序的报文段是不会 被接收方逐个确认的。因此，如图3-33所 示（也可参见图3-19), TCP发送方仅需维持已发送过但未被确认的字节的最小序号 (SendBase)和下一个要发送的字节的序号 (NextSeqNum)。在这种意义下，TCP看起来更像一个GBN风格的协议。但是TCP和 GBN协议之间有着一些显著的区别。许多 TCP实现会将正确接收但失序的报文段缓存起来[Stevens 1994]。

​		另外考虑一下，当发送方发送的一组报文段1，2,…，N，并且所有的报文段都按序无差错地到达接收方时会发生的情况。进一步假设对分组的确认报文丢失，但是其余N-1个确认报文在分别超时以前到达发送端，这时又会发生的情况。在该例中，GBN不仅会重传分组n，还会重传所有 后继的分组n + 1， n+2,…，N。在另一方面，TCP将重传至多一个报文段，即报文段N。此外，如果对报文段n + 1的确认报文在报文段n超时之前到达，TCP甚至不会重传报文段n。

​	对TCP提出的-一种修改意见是所谓的**选择确认（selective acknowledgment)** [RFC 2018], 它允许TCP接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。当将该机制与选择重传机制结合起来使用时（即跳过重传那些已被接收方选择性 地确认过的报文段），TCP看起来就很像我们通常的SR协议。因此，TCP的差错恢复机制也许最好被分类为GBN协议与SR协议的混合体。

#### 流量控制

​		前面汫过，一条TCP连接每一侧主机都为该连接设置了接收缓存。当该TCP连接收 到正确、按序的字节后，它就将数据放人接收缓存。相关联的应用进程会从该缓存中读取 数据，但不必是数据刚一到达就立即读取。事实上，接收方应用也许正忙于其他任务，甚 至要过很长时间后才去读取该数据。如果某应用程序读取数据时相对缓慢，而发送方发送 得太多、太快，发送的数据就会很容易地使该连接的接收缓存溢出。

​		TCP为它的应用程序提供了流量控制服务（flow-ccmtml service)以消除发送方使接收方 缓存溢出的可能性。流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用 程序的读取速率相四配。前面提到过，TCP发送方也可能因为IP网络的拥塞而被遏制；这种 形式的发送方的控制被称为拥塞控制（congestion control)，我们将在3. 6节和3.7节详细地 讨论这个主题。即使流量控制和拥塞控制采取的动作非常相似（对发送方的遏制），但是它 们M然是针对完全不同的原因而采取的措施。不幸的是，许多作者把这两个术语混用，理解 力强的读者会明智地区分这两种情况。现在我们来讨论TCP如何提供流量控制服务的。为了 能从整体上看问题，我们在本节都假设TCP是这样实现的，即TCP接收方丢弃失序的报文段3

​		TCP通过让发送方维护一个称为接收窗口（receive window)的变量来提供流量控制。 通俗地说，接收窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间。因为 TCP是全双工通信，在连接两端的发送方都各自维护一个接收窗口。我们在文件传输的情 况下研究接收窗口。假设主机A通过一条TCP连接向主机B发送一个大文件。主机B为 该连接分配了一个接收缓存，并用RcvBuffer来表示其大小。主机B上的应用进程不时地 从该缓存中读取数据。我们定义以下变量：
•	LastByleRead:主机B上的应用进程从缓存读出的数据流的最后一个字节的编号。
•	UstByteKcvd:从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个 字节的编号。
由于TCP不允许已分配的缓存溢出，下式必须成立：
RcvBuffer
LastByteRcvd — LastByteRead ^ RevBuffer 接收窗口用nvml表示，根据缓存可用空间的数量来设置：
rwnd = RcvBuffer - [ LastByteRcvd - LastByteRead] 由于该空间是随着时间变化的，所以 rwnd是动态的。围3-38对变量rwnd进行 了图示。
连接是如何使用变量rwnd提供流量 控制服务的呢？主机B通过把当前的 nvnd值放人它发给主机A的报文段接收 窗口字段中，通知主机A它在该连接的缓 存中还有多少可用空间。开始时，主机B 设定rwnd = RcvBuffer。注意到为了实现这