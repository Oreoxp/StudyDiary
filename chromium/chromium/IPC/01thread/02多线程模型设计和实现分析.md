# Chromium 多线程模型设计和实现分析

[TOC]

​		Chromium除了远近闻名的多进程架构之外，它的多线程模型也相当引人注目的。

​		<u>Chromium 的多进程架构是为了解决网页的稳定性问题，而多线程模型则是为了解决网页的卡顿问题。</u>

​		为了达到这个目的，**Chromium 的多线程模型是基于异步通信的。也就是说，一个线程请求另外一个线程执行一个任务的时候，不需要等待该任务完成就可以去做其它事情，从而避免了卡顿。**

​		本文就分析Chromium的多线程模型的设计和实现。



​		这里可能会有疑问，如果一个线程请求另外一个线程执行一个任务的时候，就是要等该任务完成之后才能做其它事情，那么使用异步通信有什么用呢？的确如此，但是 Chromium 提供这种基于异步通信的多线程模型，就是希望作为开发者的你在实现一个模块的时候，尽最大努力地设计好各个子模块及其对应的数据结构，使得它们在协作时可以最大程度地进行异步通信。因此，Chromium 基于异步通信的多线程模型更多的是体现一种设计哲学。

​		 一个典型的异步通信过程如下图所示：

![01线程异步通信](./markdownimage/01线程异步通信.png)



​		Task-1 被分解成三个子任务 Task-1(1)、Task-1(2) 和 Task-1(3)。

​		其中，Task-1(1) 由 Thread-1 执行。Task-1(1) 执行完成后，Thread-1 通过闭包的方式请求 Thread-2 执行Task-1(2)。Task-1(2) 执行完成后，Thread-2 又通过一个闭包请求 Thread-1 执行 Task-1(3)。至此，Task-1就执行完成。

​		<u>我们可以将第一个闭包看作是一个 Request 操作，而第二个闭包是一个 Reply 操作。</u>这是一个典型的异步通信过程。当然，如果不需要知道异步通信结果，那么第二个闭包和 Task-1(3) 就是不需要的。

​		假设 Thread-1 需要知道异步通信的结果，那么在上图中我们可以看到一个非常关键的点：Thread-1 并不是什么也不干就只是等着 Thread-2 执行完成 Task-1(2)，它趁着这个等待的空隙，干了另外一件事情——Task-2。如果我们将 Thread-1 看作是一个UI线程，那么就意味着这种异步通信模式是可以提高它的响应性的。

​		为了能够完成上述的异步通信过程，一个线程的生命周期如下图所示：

![02线程生命周期](./markdownimage/02线程生命周期.png)

​		线程经过短暂的启动之后（Start），就围绕着一个任务队列（TaskQueue）不断地进行循环，直到被通知停止为止（Stop）。在围绕任务队列循环期间，它会不断地检查任务队列是否为空。如果不为空，那么就会将里面的任务（Task）取出来，并且进行处理。这样，一个线程如果要请求另外一个线程执行某一个操作，那么只需要将该操作封装成一个任务，并且发送到目标线程的任务队列去即可。

​		为了更好地理解这种基于任务队列的线程运行模式，我们脑补一下另外一种常用的基于锁的线程运行模式。一个线程要执行某一个操作的时候，就直接调用一个代表该操作的一个函数。如果该函数需要访问全局数据或者共享数据，那么就需要进行加锁，避免其它线程也正在访问这些全局数据或者共享数据。这样做的一个好处是我们只需要关心问题的建模，而不需要关心问题是由谁来执行的，只要保证逻辑正确并且数据完整即可。当然坏处也是显然的。首先是为了保持数据完整性，也就是避免访问数据时出现竞争条件，代码里面充斥着各种锁。其次，如果多个线程同时获取同一个锁，那么就会产生竞争。这种锁竞争会带来额外的开销，从而降低线程的响应性。

​		**<u>基于任务队列的线程运行模式，要求在对问题进行建模时，要提前知道谁是执行者。也就是说，在对问题进行建模时，需要指派好每一个子问题的执行者。这样我们为子问题设计数据结构时，就规定这些数据结构仅仅会被子问题的执行者访问。这样执行者在解决指派给它的问题时，就不需要进行加锁操作，因为在解决问题过程中需要访问的数据不会同时被其它执行者访问。这就是通过任务队列来实现异步通信的多线程模型的设计哲学。</u>**

​		当然，这并不是说，基于任务队列的线程运行模式可以完全避免使用锁，因为任务队列本身就是一个线程间的共享资源。想象一下，一个线程要往里面添加任务，另一个线程要从里面将任务提取出来处理。因此，所有涉及到任务队列访问的地方都是需要加锁的。但是如果我们再仔细想想，那么就会发现，任务队列只是一个基础设施，它与具体的问题是无关的。因此，只要我们遵循上述设计哲学，就可以将代码里面需要加锁的地方仅限于访问任务队列的地方，从而就可以减少锁竞争带来的额外的开销。

​		这样说来，似乎基于任务队列的线程运行模式很好，但是实际上它对问题建模提出了更高的要求，也就是进行子问题划分时，要求划分出来的子问题是正交的，这样我们才有可能为这些子问题设计出不会同时被访问的数据结构。看到“正交”两个字，是不是想起高数里面的向量空间的正交基了？或者傅里叶变换用到的一组三角函数了？其实道理就是一样一样的。



​		好了，说了这么多，我们就步入到正题，分析Chromium多线程模型的设计和实现，也就是基于任务队列的线程运行模式涉及到核心类图，如下图所示：

![02任务队列线程运行模式](./markdownimage/02任务队列线程运行模式.png)

​		Thread 是一个用来创建带消息循环的类。当我们创建一个 Thread 对象后，调用它的成员函数 Start 或者StartWithOptions 就可以启动一个带消息循环的线程。其中，成员函数 StartWithOptions 可以指定线程创建参数。当我们不需要这个线程时，就可以调用之前创建的 Thread 对象的成员函数 Stop。

​		Thread 类继承了 PlatformThread::Delegate 类，并且重写了它的成员函数 ThreadMain 。我们知道，Chromium 是跨平台的，这样各个平台创建线程使用的 API 有可能是不一样的。不过，我们可以通过PlatformThread::Delegate 类为各个平台创建的线程提供一个入口点。这个入口点就是PlatformThread::Delegate 类的成员函数 ThreadMain。由于 Thread 类重写了父类 PlatformThread::Delegate的成员函数 ThreadMain，因此无论是哪一个平台，当它创建完成一个线程后，都会以 Thread 类的成员函数ThreadMain 作为线程的入口点。

​		Thread 类有一个重要的成员变量 message_loop_ ，它指向的是一个 MessageLoop 对象。这个MessageLoop 对象就是用来描述线程的消息循环的。MessageLoop 类内部通过成员变量 run_loop_ 指向的一个RunLoop 对象和成员变量 pump_ 指向的一个 MessagePump 对象来描述一个线程的消息循环。

​		一个线程在运行的过程中，可以有若干个消息循环，也就是一个消息循环可以运行在另外一个消息循环里面。除了最外层的消息循环，其余的消息的消息循环称为嵌套消息循环。我们为什么需要嵌套消息循环呢？这主要是跟模式对话框有关。

​		<u>考虑一个情景，我们在一个窗口弹出一个文件选择对话框。窗口必须要等到用户在文件选择对话框选择了文件之后，才能去做其它事情。窗口是在消息循环过程中打开文件对话框的，它要等待用户在文件选择对话框中选择文件 ，就意味着消息循环被中止了。由于文件选择对话框也是通过消息循环来响应用户输入的，因此如果打开的它窗口中止了消息循环，就会导致它无法响应用户输入。为了解决这个问题，就要求打开文件选择的窗口不能中止消息循环。方法就是该窗口创建一个子消息循环，该子消息循环负责处理文件选择对应框的输入事件，直到用户选择了一个文件为止。</u>



# 当前版本基于任务队列的线程模型实现方式

​		随着时间的推移，为了进一步简化和提高效率，Chromium 逐渐弃用 `MessageLoop`，转而使用基于`base::sequence_manager::SequenceManager` 和 `base::sequence_manager::TaskQueue` 的模型。这个新模型提供了更为细粒度的控制，允许更复杂的任务调度策略，同时还支持任务的优先级、延迟等特性。

​		`base::sequence_manager::TaskQueue` 是一个代表一系列任务的队列，这些任务将按照它们被添加的顺序执行。而 `SequenceManager` 则管理多个这样的任务队列，负责调度它们的执行。

​		这些变更使得 Chromium 的任务调度更为灵活和高效，满足了其不断增长和复杂化的需求。



## 基本概念

### 线程 

每个 Chrome 进程都有：

- **一个主线程** 
  - 在浏览器进程中（BrowserThread::UI）：更新UI 
  - 在渲染进程中（Blink主线程）：运行Blink的大部分 
- **一个 IO 线程** 
  - 在所有进程中：所有 IPC 消息都在此线程上到达。处理消息的应用程序逻辑可能在另一个线程中（即，IO线程可能将消息路由到绑定到不同线程的 Mojo 接口）。 
  - 更一般地说，大多数异步 I/O 都在这个线程上发生（例如，通过base::FileDescriptorWatcher）。 
  - 在浏览器进程中：这被称为BrowserThread::IO。 
- 还有一些特定目的的线程 
- 以及一个通用线程池 

大多数线程都有一个 LOOP ，从队列中获取任务并运行它们（队列可能在多个线程之间共享）。

### Tasks

​		Task 是添加到队列中以异步执行的 base::OnceClosure。

​		base::OnceClosure 存储一个函数指针和参数（类似 std::bind）。它有一个 Run() 方法，使用绑定的参数调用函数指针。它是使用 base::BindOnce 创建的。（参考[Callback<> and Bind() documentation](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/callback.md)文档）。

```c++
void TaskA() {}
void TaskB(int v) {}

auto task_a = base::BindOnce(&TaskA);
auto task_b = base::BindOnce(&TaskB, 42);
```

一组任务可以按以下方式之一执行：

- 并行：没有任务执行顺序，可能所有任务都在任何线程上一次性执行
- 顺序：任务按发布顺序执行，一次在任何线程上执行一个。 
- 单线程：任务按发布顺序执行，在单个线程上一次执行一个。 
  - COM 单线程：带有初始化的 COM 的单线程变体。

### 序列优先于物理线程

​		顺序执行（在虚拟线程上）比单线程执行（在物理线程上）更受青睐。除了绑定到主线程（UI）或 IO 线程的类型/方法：通过 base::SequencedTaskRunner 实现线程安全比管理自己的物理线程更好（参考下面的发布顺序任务）。

​		所有为“当前物理线程”公开的 API 都有一个“当前序列”的等价物（映射）。

​		如果你发现自己正在编写一个序列友好的类型，并且它在叶依赖中未通过线程亲和性检查（例如，THREAD_CHECKER）：请考虑使该依赖也成为序列友好的。Chrome 中的大多数核心 API 都是序列友好的，但一些遗留类型可能仍然过于严格地使用 ThreadChecker/SingleThreadTaskRunner，而它们可以依赖于“当前序列”而不再是线程亲和的。





## 实现类

### 废弃 MessageLoop

​		Chromium 的代码库在经历一系列的重构后，其中一个较大的变动是 `base::MessageLoop` 被废弃并由新的任务调度模型取而代之。其中，`base::Thread` 的设计也发生了改变，移除了 `message_loop_` 成员。新的调度模型更加灵活，并解决了之前模型中存在的一些问题。

在新的模型中：

1. **base::Thread**：
   - 仍然是一个线程的高级表示，但现在不直接持有一个 `MessageLoop` 实例。
   - `base::Thread` 现在使用 `base::sequence_manager::SequenceManager` 和 `base::sequence_manager::TaskQueue` 来处理和调度任务。
2. **base::sequence_manager::SequenceManager**：
   - **<u>管理任务队列并与 `MessagePump` 交互以驱动任务的执行。</u>**
3. **base::sequence_manager::TaskQueue**：
   - 表示任务队列。任务可以推送到这些队列中，并由 `SequenceManager` 管理和调度。

要将任务推送到线程上，请执行以下操作：

1. 首先，确保线程已经启动。这可以通过调用 `base::Thread::Start()` 来完成。
2. 使用 `base::Thread::task_runner()` 获取与线程关联的 `TaskRunner`。
3. 使用 `TaskRunner` 的 `PostTask` 方法将任务推送到线程上。

示例代码：

```C++
base::Thread my_thread("MyThread");
my_thread.Start();
my_thread.task_runner()->PostTask(FROM_HERE, base::BindOnce([]() {
    std::cout << "123";
}));
```

注意：这是一个简化的示例。在实际的Chromium代码库中，可能还需要处理其他细节，特别是关于线程的生命周期、任务的取消和错误处理等方面。

​		在Chromium的新的任务调度模型中，任务通常不再直接添加到`MessageLoop`上，而是通过`TaskRunner`来进行。`TaskRunner`是一个可以将任务发送到特定的执行环境（例如线程或序列）的对象。

​		特别是，`base::Thread`类提供了一个`task_runner()`方法，该方法返回一个`scoped_refptr<SingleThreadTaskRunner>`。`SingleThreadTaskRunner`是`TaskRunner`的一个子类，它确保所有的任务都在同一个线程上运行。

```c++
scoped_refptr<SingleThreadTaskRunner> task_runner()
```



### SingleThreadTaskRunner

- 这是一个`SequencedTaskRunner`，但所有任务都在一个单独的线程上运行。
- 这个实现可能会：向现有线程的`MessageLoop`发布任务；为发布任务创建自己的工作线程和`MessageLoop`；或者将任务添加到 FIFO 并向非`MessageLoop`线程发出信号以便它们被处理。

![02SingleThreadTaskRunner](./markdownimage/02SingleThreadTaskRunner.png)

1. **BelongsToCurrentThread()**:
   - 更明确的别名，指向`RunsTasksInCurrentSequence()`。判断当前任务是否属于当前线程。
2. **GetCurrentDefault()**:
   - 返回当前线程的默认`SingleThreadTaskRunner`。在为多个任务队列提供服务的线程上，优先使用默认的任务队列。
3. **HasCurrentDefault()**:
   - 返回是否为当前线程创建了`SingleThreadTaskRunner`。
4. **CurrentDefaultHandle**:
   - 这是一个嵌套类，允许将特定的`SingleThreadTaskRunner`绑定到当前线程。
5. **CurrentHandleOverride**:
   - 这是另一个嵌套类，允许在其生命周期内重写`SingleThreadTaskRunner::GetCurrentDefault()`返回的任务运行器。通常这样的重写在特殊情况下是需要的，因此它在某些特定的上下文中有一定的访问限制（如`friend`声明）。
   - 这个类还涉及到允许或不允许在其生命周期内运行的`RunLoop::Run()`。
6. **CurrentHandleOverrideForTesting**:
   - 专门为测试目的设计的嵌套类，允许重写`CurrentHandleOverrides`。通常不建议在非测试环境中嵌套使用`CurrentHandleOverrides`，但在某些单元测试中，多个任务运行器为了简单性和确定性共享主线程。

​        最后，像许多其他 Chromium 类一样，它在析构函数中使用了`override = default`，确保子类的析构函数在适当的时候被调用。

​        总的来说，`SingleThreadTaskRunner`为在单个线程上运行的任务提供了一个高级抽象，使得任务调度更为简单和可靠。



### SequencedTaskRunner























