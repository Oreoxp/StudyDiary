### 情形1：以异步方式调用函数

​		为了用线程池来以异步的方式执行一个函数，我们需要定义一个具有以下原型的函数：

```c++
VOID NTAPI SimpleCallBack(
	PTP_CALLBACK_INSTANCE pInstance,
	PVOID  pvContext
);
```

​		然后为了让线程池中的一个线程执行该函数，我们需要向线程池提交一个请求。为了达到这个目的，我们只需调用下面的函数：

```c++
BOOL TrySubmitThreadpoolCallback(
	PTP_SIMPLE_CALLBACK pfnCallback,
	PVOID pvContext,
	PTP_CALLBACK_ENVIRON pcbe
);
```

该函数(通过调用**PostQueuedCompletionStatus**来)将一个**工作项（work item）**添加到线程池的队列中，若调用成功，则返回**TRUE**，若调用失败，则返回**FALSE**。在调用**TrySubmitThreadpoolCallback**的时候，**pfnCallback**参数用来标识我们编写的那个符合**SimpleCallBack**原型的函数；

**pvContext**是一个应该（通过**SimpleCallBack**的**pvContext**参数）传给我们的值；

我们可以直接给**PTP_CALLBACK_ENVIRON**参数传**NULL**。



​		注意，我们从来不需要自己调用**CreateThread**，系统会自己为我们的进程创建一个默认的线程池，并让线程池中的一个线程来调用我们的回调函数。

​		此外，当这个线程处理完一个客户请求之后，它不会立刻被销毁，而是回到线程池，准备好处理队列中的任何其他工作项。线程池会不断地重复使用其中的线程，而不会频繁地创建和销毁线程。对应用来说，这样可以显著地提升性能，因为创建和销毁线程会消耗大量的事件。当然，如果线程池检测到它的线程数量供过于求，那么它就会销毁其中一些线程。除非我们非常清楚自己在做上面，否则的话最好还是相信线程池的内部算法，让他自动地对程序的工作进行微调

