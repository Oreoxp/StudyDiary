# poll epoll select有什么区别

`poll`、`epoll` 和 `select` 都是用于管理多路 I/O 事件的系统调用，主要用于处理多个文件描述符上的读写事件。它们的区别如下：

### 1. **`select`**

- **特点**：`select` 是最早引入的多路复用 I/O 机制，支持监控多个文件描述符的读写和异常状态。
- **接口**：通过将所有要监控的文件描述符放入一个集合中，每次调用时都需要重新填充集合。
- 优点：
  - 兼容性好，几乎所有操作系统都支持。
- 缺点：
  - **文件描述符限制**：`select` 受限于 `FD_SETSIZE`（通常是 1024 个文件描述符），无法监控大量描述符。
  - **每次调用都要重设集合**：需要每次重新将文件描述符加入集合中，效率较低。
  - **线性扫描**：`select` 的实现是线性遍历所有文件描述符，效率较低，尤其是在大量空闲文件描述符的情况下。

### 2. **`poll`**

- **特点**：`poll` 是 `select` 的改进版，消除了文件描述符数量的限制。
- **接口**：通过传递一个数组结构来指定要监控的文件描述符及其事件，每次调用时仍需传递完整的文件描述符列表。
- 优点：
  - 没有文件描述符数量的硬性限制（只受系统内存限制）。
  - 支持更灵活的事件集合。
- 缺点：
  - 和 `select` 类似，每次调用都需要传递整个文件描述符数组，处理大量文件描述符时性能不高。
  - 实现依然是线性扫描，即使只有部分文件描述符有事件需要处理，也要遍历整个数组。

### 3. **`epoll`**

- **特点**：`epoll` 是 Linux 特有的高效多路复用机制，设计用于处理大量并发连接。`epoll` 分为 `epoll_create`、`epoll_ctl` 和 `epoll_wait` 三个步骤。
- **接口**：与 `select` 和 `poll` 不同，`epoll` 使用一个内核对象来保存监控的文件描述符集合，**注册后无需每次传递整个文件描述符列表，只需调用 `epoll_wait` 等待事件**。
- 优点：
  - **高效性**：通过事件驱动机制，只返回有事件的文件描述符，避免了线性扫描。
  - **持久性**：文件描述符的注册是持久的，不需要每次都传递，减少了用户态和内核态之间的切换开销。
  - **支持大规模连接**：性能随文件描述符数量增加影响较小，适用于高并发场景。
- 缺点：
  - 只在 Linux 上可用，移植性不如 `select` 和 `poll`。
  - 在极少数场景下，事件的边缘触发模式可能带来复杂性。

### 总结

- **`select`**：适合小规模文件描述符的场景，兼容性好，但性能和文件描述符数量有限制。
- **`poll`**：与 `select` 类似，解决了文件描述符限制问题，但在大规模并发下性能依旧有限。
- **`epoll`**：适合大规模并发连接的场景，性能最优，尤其是在高并发和大量 I/O 事件的场景下表现突出。