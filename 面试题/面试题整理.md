# bilibili面试题整理

很好的面试题整理：https://www.zhihu.com/column/c_1281621296304996352





## C 和 C++ 的区别



## 指针和引用的区别

1、指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；

2、可以有const指针，但是没有const引用；

3、指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）；

4、指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。



## malloc 和 new，free 和 delete 的区别

## extern C 的作用

使下面的代码用c语言的方式编译。

## volatile 关键字的作用

使变量不用编译优化，必须从内存中读取

## 常用的容器有哪些

vector、set、map、

## 有哪几种强制类型转换以及使用场景

const_cast : 去 const；
static_cast：普通强制转换；
dynamic_cast：动态类型转换；
reinterpret_cast：指针转向足够大的整数类型、从整形或者enum枚举类型转换为指针、从函数指针转向另一个不同类型的函数指针、从一个对象指针转向另一个不同类型的对象指针。



## C++ 的三大特性

封装、继承、多态

## C++的多态实现原理

​		在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。虚函数表

## 什么是虚函数

​	用 virtual 关键字申明的函数叫做虚函数

## 什么是纯虚函数

​	纯虚函数是虚函数再加上 = 0

## 虚表指针的大小

64位下8个字节，32位下4个字节，就是一个指针的大小。

## 虚函数表的存放内容

父类和子类的虚函数地址

## 构造函数可以是虚函数吗

不可以，vtable还没初始化，而且构造函数中不能调用虚函数。

## 析构函数可以是虚函数吗

可以，vtable 已经初始化。
**类有继承时，析构函数必须为虚函数。**如果不是虚函数，则使用时可能存在**内存泄漏**的问题。

## 一个空类会生成哪些函数

缺省构造函数
拷贝构造函数
析构函数 
赋值运算符

## 左值和右值

一个左值表达式表示的是一个**<u>对象</u>**的身份，而一个右值表达式表示的是**<u>对象的值</u>**。

右值引用只能绑定到临时对象！

move函数作用：左值变右值；

## 什么是智能指针，有哪几种，作用，实现原理

shared_ptr：含有引用计数，当计数为0的时候销毁对象，一般用来分享。

unique_ptr：与**shared_ptr**不同，某个时刻只能有一个**unique_ptr**指向一个给定对象。<u>当**unique_ptr**被销毁时，它所指向的对象也被销毁</u>。

weak_ptr：weak_ptr 是一种<u>不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。</u>将一个weak_ ptr绑定到一个 shared_ptr 不会改变shared_ptr 的引用计数。

## 如何避免循环依赖

“ **循环引用** ” 简单来说就是：两个对象互相使用一个 shared_ptr 成员变量指向对方的会造成循环引用。导致引用计数失效。

即A内部有指向B，B内部有指向A，这样对于A，B必定是在A析构后B才析构，对于B，A必定是在B析构后才析构A，这就是循环引用问题，违反常规，导致内存泄露。

解决办法：

**1**. 当只剩下最后一个引用的时候需要手动打破循环引用释放对象。
**2**. 当A的生存期超过B的生存期的时候，B改为使用一个普通指针指向A。
**3**. 使用弱引用的智能指针打破这种循环引用。

## unique_ptr 中 std::move() 作用

​		unique_ptr不能直接复制，必须使用`std::move()`转移其管理的指针，转移后原 unique_ptr 为空。

## static 关键字的使用

静态成员变量是该类的所有对象所共有的

静态成员变量存储在全局数据区

sizeof 运算符不会计算 静态成员变量

## const 关键字的使用

const在*号之前指向的内容不可修改；

const在*好之后指针值不可修改。

## define 和 inline 的区别

define：**定义预编译时处理的宏**；
 只进行简单的字符替换，无类型检测

typedef：**定义类型别名 用于处理复杂类型
** 例： typedef int A；
 则：A a； //定义a为int

inline: **内联函数对编译器提出建议，是否进行宏替换，编译器有权拒绝**

 既为提出申请，不一定会成功

## 面向对象的设计原则

​		**面向对象程序设计(object-oriented programming)**的核心思想是**<u>数据抽象</u>**、**<u>继承</u>**和**<u>动态绑定</u>**。

​		通过使用<u>数据抽象</u>，我们可以将类的接口与实现分离;
​		使用<u>继承</u>，可以定义相似的类型并对其相似关系建模;
​		使用<u>动态绑定</u>，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

## C++ 编译过程

## <img src="/Users/duxinpei/Library/Containers/com.tencent.qq/Data/Library/Application Support/QQ/Users/2535099352/QQ/Temp.db/F88696E3-AC18-4B31-B501-962B8501DD50.png" alt="F88696E3-AC18-4B31-B501-962B8501DD50" style="zoom:150%;" />函数调用的具体实现

https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601204.html





# 计算机网络

## 三次握手和四次挥手

- **TCP 的三次握手过程如下：**
  C-> SYN -> S
  S->SYN/ACK->C
  C->ACK->S
- **TCP 的四次挥手过程如下：**
  C->FIN->S
  S->ACK->C
  S->FIN->C
  C->ACK->S

​        **三次握手的原因：** **<u>三次握手可以防止已经失效的连接请求报文突然又传输到服务器端导致的服务器资源浪费</u>**。
​        **四次挥手的原因：** **<u>由于连接的关闭控制权在应用层，所以被动关闭的一方在接收到 FIN 包时，TCP 协议栈会直接发送一个 ACK 确认包，优先关闭一端的通信。然后通知应用层，由应用层决定什么时候发送 FIN 包。应用层可以使用系统调用函数 read==0 来判断对端是否关闭连接。</u>**

## 四次挥手为什么要有 close_wait 状态

可能是server端还有数据没发送完。

## tcp 长时间不断开连接会不会断连

默认好像是4秒还是五秒，不过你可以设置socket的keepalive为true,这样即使没有数据，tcp/ip的底层也会保持连接，虽然tcp/ip的规则不建议这样做；

## tcp 如何保证可靠传输

**（1）序列号、确认应答、超时重传:**数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2 * RTT(报文段往返时间）+ 一个偏差值。*

**（2）窗口控制与高速重发控制/快速重传（重复确认应答）:**TCP 会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，<u>窗口大小就是无需等待确认而可以继续发送数据的最大值</u>。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到 3 次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒……

**（3）拥塞控制:**如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以 TCP 在为了防止这种情况而进行了拥塞控制。
			**慢启动**：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小2。
			**拥塞避免**：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。
			**快速重传**：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。这样可以达到：**在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。**

## TCP 和 UDP 的区别

1、基于连接与无连接；

2、对系统资源的要求（TCP较多，UDP少）；

3、UDP程序结构较简单；

4、流模式与数据报模式 ；

5、TCP保证数据正确性，UDP可能丢包；

6、TCP保证数据顺序，UDP不保证。

## UDP 怎么实现可靠传输

​		传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。

- 1、添加seq/ack机制，确保数据发送到对端
- 2、添加发送和接收缓冲区，主要是用户超时重传。
- 3、添加超时重传机制。

## Udp穿墙问题

## http 和 https 的区别

**HTTP 协议和 HTTPS 协议区别如下：**
1）HTTP 协议是以<u>明文</u>的方式在网络中传输数据，而HTTPS协议传输的数据则是经过<u>TLS加密</u>后的，HTTPS 具有更高的安全性
2）HTTPS 在 TCP 三次握手阶段之后，还需要进行 SSL 的 handshake，协商加密使用的对称加密密钥
3）HTTPS 协议需要服务端申请证书，浏览器端安装对应的根证书
4）HTTP 协议端口是 80 ，HTTPS 协议端口是 443 

## 怎么解决粘包问题

​		TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。

## 如何解决

（1）发送方

对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。

（2）接收方

接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。

（2）应用层

应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。

解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？

格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。
发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。

### UDP会不会产生粘包问题呢？

​		TCP基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的。

​		UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。

## 拥塞控制

**1、慢开始：** 最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过大。
**2、拥塞避免：** 每经过一个往返时间RTT，cwnd就增长1。另外在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）
**3、快重传：** 接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。
**4、快恢复：** 当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。
采用快恢复算法时，慢开始只在建立连接和网络超时才使用。

- 采用慢开始和拥塞避免算法的时候

1. 一旦cwnd>慢开始门限，就采用拥塞避免算法，减慢增长速度
2. 一旦出现丢包的情况，就重新进行慢开始，减慢增长速度

- 采用快恢复和快重传算法的时候

1. 一旦cwnd>慢开始门限，就采用拥塞避免算法，减慢增长速度
2. 一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度

## 流量控制

**滑动窗口机制：**
		滑动窗口协议的基本原理就是在任意时刻，发送方都维持了一个连续的允许发送的帧的序号，称为发送窗口；同时，接收方也维持了一个连续的允许接收的帧的序号，称为接收窗口。发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同。不同的滑动窗口协议窗口大小一般不同。发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧。

## 拥塞控制和流量控制的区别

​		拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。

## 如何判断网络拥塞

增加数据包的发送数量。

## GET 和 POST 的区别

**		对于GET方式的请求**，浏览器会把 http header 和 data 一并发送出去，服务器响应200（返回数据）；**而对于POST**，浏览器先发送 header，服务器响应100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。

## cookie 和 session 区别

cookie数据保存在客户端，session数据保存在服务器端。

## DNS 的原理

1、首先客户端位置是一台电脑或手机，在打开浏览器以后，比如输入[http://www.zdns.cn](https://link.zhihu.com/?target=http%3A//www.zdns.cn)的域名，它首先是由浏览器发起一个DNS解析请求，如果本地缓存服务器中找不到结果，则首先会向根服务器查询，根服务器里面记录的都是各个顶级域所在的服务器的位置，当向根请求[http://www.zdns.cn](https://link.zhihu.com/?target=http%3A//www.zdns.cn)的时候，根服务器就会返回.cn服务器的位置信息。

2、递归服务器拿到.cn的权威服务器地址以后，就会寻问cn的权威服务器，知不知道[http://www.zdns.cn](https://link.zhihu.com/?target=http%3A//www.zdns.cn)的位置。这个时候cn权威服务器查找并返回[http://zdns.cn](https://link.zhihu.com/?target=http%3A//zdns.cn)服务器的地址。

3、继续向[http://zdns.cn](https://link.zhihu.com/?target=http%3A//zdns.cn)的权威服务器去查询这个地址，由[http://zdns.cn](https://link.zhihu.com/?target=http%3A//zdns.cn)的服务器给出了地址：202.173.11.10

4、最终才能进行http的链接，顺利访问网站。

5、这里补充说明，一旦递归服务器拿到解析记录以后，就会在本地进行缓存，如果下次客户端再请求本地的递归域名服务器相同域名的时候，就不会再这样一层一层查了，因为本地服务器里面已经有缓存了，这个时候就直接把[http://www.zdns.cn](https://link.zhihu.com/?target=http%3A//www.zdns.cn)的A记录返回给客户端就可以了。

## cdn的原理

Dns:本地-》dns服务器-》本地-》业务服务器

cdn：本地-》dns服务器-》业务服务器





# 数据结构

## 什么是跳表

​		跳表是一个随机化的数据结构，跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。

## 一个两层的跳表查询时可以降低倒多大的复杂度

50%

## vector 和 list 的区别

vector是数组  list是双向链表

## vector 的扩容原理

​		触发扩容时，如果要插入的数据量比旧容量小，则按两倍扩容；如果要插入的数据量比原来的旧容量还要大，即表示即使按两倍扩容了，依然存不下要插入的数据，此时将会按照旧容量加要插入的数据量来扩容，保证一次扩容就能容下要插入的数据

## map 底层实现

map以红黑树为底层机制。红黑树是一种二叉平衡搜索树，自动排序效果不错

## map 和 unordered_map 的区别

map： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。

unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的

## Set 底层实现

Set以红黑树为底层机制。

## 如何计算循环链表的长度

用快慢指针先相遇，然后用另一个指针在快指针处移动一圈就行循环链表的长度。

## 二叉搜索树和平衡二叉树，红黑树的区别

二叉搜索数：所有的左节点都小于根节点值，所有的右节点都大于根节点值

平衡二叉树：在二叉搜索树的概念上加入平衡因子：左右子树高度差不能大于1.

红黑树：在二叉搜索树的概念上加入颜色概念，如果一个节点是红色，那么它的两个子节点必定是黑色，父节点也是黑色。

## 红黑树删除数据是怎么调整的

## 什么是哈希表，哈希函数，怎么解决冲突

常用的Hash冲突解决方法有以下几种：

## **1.开放定址法**

这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。

## **2.再哈希法**

这种方法是同时构造多个不同的哈希函数：

Hi=RH1（key） i=1，2，…，k

当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。

## **4.建立公共溢出区**

这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

## stl sort 函数的实现

# 算法

二叉树的层序遍历

反转链表

实现 strStr()

快速排序时间复杂度，实现原理

形成三的超大倍数

两数相加

回文链表

二叉树的最近公共祖先



# 操作系统

## 操作系统分段、分页

分页机制的思想是:通过映射，可以使连续的线性地址与物理地址相关联，逻辑上连续的线性地址对应的物理地址可以不连续。 分页的作用 - 将线性地址转换为物理地址 - 用大小相同的页替换大小不同的段

## 定时器的实现

时间轮算法

## 读写锁



## 如果读写锁占用很长时间，并且后续还有读者不断占用读锁，这就造成了写者饥饿的问题，怎么解决？

读写锁初始化可以设置写锁优先加入队列

## 自旋锁

## 乐观锁和悲观锁

- 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
- 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。

## select、poll 和 epoll 的区别

select：轮询io

poll：轮询io，但是poll没有最大文件描述符数量的限制

epoll：等io自己触发

## 为啥 epoll 为啥能突破文件上限大小

因其基于链表存储

## 水平触发和边缘触发的区别

## 线程和进程的区别

## 进程之间的状态转换

## 如何创建多线程

## 如何实现线程同步

## 进程之间的通信方式

## 什么是协程，什么情况下可以使用协程

## 了解线程模型吗？用户态的线程怎么和内核态的线程映射的

## 动态链接和静态链接的区别

## 如何创建一个守护进程

## 孤儿进程和僵尸进程

## 系统是如何检测孤儿进程的

Docker 的优缺点

## 虚拟内存的实现原理

内存泄漏和内存溢出是指什么，内存溢出有什么危害

## 数据库

redis 的数据类型
redis 的缓存删除策略
redis 怎么实现的定期删除
mysql 中使用的锁有哪些？什么时候使用行锁，什么时候会使用表锁
mysql 的 binlog 日志什么时候会使用
undo 日志和 redo 日志分别是干嘛的
事务还没执行完数据库挂了，重启的时候会发生什么
数据库的 MVCC 的实现原理
事务隔离级别