## 表的实现

​		在本节中，提供了一个可用的 list 类模板的实现。和 vector 类中的情况一样，我们的表类还是命名为 XList 以避免与库类的混淆。

​		回顾一下，前面提到的 XList 类将要作为双向链表来实现，并且我们需要修改指向表两端的指针。只要操作是发生在已知位置，这样做就可以保证每个操作的时间消耗为常量。这个已知位置可以是末尾，也可以是迭代器指定的位置。

​		考虑到设计需要，我们需要提供下面的 4 个类：

1. List 类本身。包含连接到表两端的链接、表的大小以及一系列的方法。

2. Node 类。该类看起来像是私有的嵌套类。一个结点包含数据和用来指向其前和其后的结点的指针，以及适当的构造函数。

3. const_iterator 类。该类抽象了位置的概念，是一个公有的嵌套类。const_iterator 存储指向当前结点的指针，并且提供基本迭代器操作的实现，以及所有的重载操作符，例如 =、==、！=和++。

4. iterator 类。该类抽象了位置的概念，是一个公有的嵌套类。除了 operator* 操作返回所指向项的引用，而不是该项的常量引用的功能外，iterator 具有与 const_iterator 相同的功能。一个重要的技术点是 iterator 可以用于任何需要使用 const_iterator 的例程里，反之则不是。换句话说，iterator 就是 const_iterator。

​        因为迭代器类存储指向 “ 当前结点 ” 的指针，并且尾部标志是一个有效的位置，这使得在表的末尾添加一个额外的结点来作为尾部标志成为可能。进一步地，也可以在表的前端生成一个额外的结点，从而逻辑上作为开始标志。这些额外的结点有时被称为**哨兵结点**；特别地，在头部的结点有时候称为**表头结点（header node)**，而在末端的结点称为**尾结点（tail node)**。

​		使用这些额外结点的好处是可以去掉很多特例，这极大地简化了程序代码。例如，如果我们不使用表头结点，那么删除第一个结点将成为一个特例，因为我们必须在删除过程中重新设置表的链接到第一个结点上，而且删除算法一般来说也需要访问被删除结点前面的结点（没有表头结点，第一个结点前面就没有结点了）。图3-9是带有表头结点和尾结点的双向链表。图3-10是空双向链表。

![05具有表头节点和尾结点的双向链表](./markdowniamge/05具有表头节点和尾结点的双向链表.png)

![05具有表头节点和尾结点的空双向链表](./markdowniamge/05具有表头节点和尾结点的空双向链表.png)

图3-11和图3-12是List类的概要和部分实现。

![05list类](./markdowniamge/05list类.png)

​		观察第 5 行私有嵌套的 Node 类的声明的开始部分，可以看到这里使用了 struct 而不是使用 class 关键字。在 C++ 中 ，struct 是 C 编程语言遗留下来的产物。C++ 中的 struct 在本质上来说就是其成员默认为公有的class。回顾一下，在 class 中，其成员都是私有的。很明显，struct 关键字不是必需的，然而，还是经常可以看到程序员在声明一个大部分数据需要直接访问而不是使用方法来访问的类型时使用 struct 。在我们的例子中，令Node 类中的成员为 public 并不会成为什么问题，因为 Node 类本身是私有的并且不允许来自 List 类之外的访问。

![05list类续](./markdowniamge/05list类续.png)

​		观察第 9 行的公有嵌套的 const_iterator 类的声明的开始部分和第 12 行公有嵌套的 iterator 类的声明的开始部分，可以看到这里有一个不常见的语法 inheritance (这是一个功 能强大的结构，在本书的其他部分则没有用到）。继承语法是说，iterator具有与 const_iterator 完全相同（有可能会多一些）的功能，并且iterator与const_iterator的数 据类型是完全兼容的。所有需要使用const_iterator的地方都可使用iterator。在以后遇到实 际的实现的时候我们再讨论这些细节。

​		第70〜72行是List的数据成员，命名了指向表头结点和尾结点的指针。我们也将记录数据成 员的大小，这样一来size方法就可以在常量的时间内实现。

​		List类的其他部分包括构造函数、三大函数和一些方法。许多的方法都是一行的。begin 和end返回适当的迭代器；第26行的调用是一个典型的实现，在实现中返回一个已构造的迭代器 (这样iterator和const_iterator类每一个都有自己的构造函数，该构造函数使用指向Node的指针作为参数）。

第39~43行的clear方法执行的时候重复地执行删除操作来删除每一项，直到List变为空的为止。使用这种策略可以避免clear染指结点空间的回收。现在结点空间的回收已经归入 pop_front来执行。第44〜59行的方法都是通过巧妙地包含和使用恰当的迭代器来工作的。回顾 一下，insert方法在某个位置之前插入，因此，在需要的时候，push_back在末尾标记之前插入。 对于pop_back，注意erase(--end())生成了一个对应末尾标记的临时迭代器，后移这个临时迭 代器，然后使用这个迭代器来执行erase。back也使用相似的L:作原理。注意，在pop_front和 pop_back操作时，我们再一次避免使用结点回收。

图3-13是Node类。该类包括所存储的项、指向Node之前及之后的指针和…个构造函数。所 有的数据成员都是公有的。

![05list类的嵌套的node类](./markdowniamge/05list类的嵌套的node类.png)

图3-14是cons t_iterator类；图3-15是iterator类。正如我们早前提到过的，图3-15屮第

39行的语法即是称为继承性的闻级特性。这也就意味着iterator就是const_iterator。当 iterator类使用这样的方式来编写时，该类就从const_iterator继承了所有的数据和方法。然 后就可以对iterator类添加新的数据或添加新的方法，以及覆盖（例如重新定义）已有的方法^ 在最一般的情况下，将会产生显著的语法包袱（常常致使关键字virtual出现在代码中）。

然而，在本例中，这许多的语法包衹是可以避免的，因为我们既不添加新的数据，又不试图

__改变已有方法的运作。但是，我们添加一些新的方法到iterator类中（用与const_iterator类

中已有的方法非常相似的符号）。这样一来就避免了使用virtual。虽然如此，在const_iterat〇r 中还是有相.¾数量的语法技巧。

在第28和29行，const_iterator像存储它的单一数据成员一样存储指向“当前”结点的指 针。一般地，这个指针都是私有的，但是如果是私有的，那么iterator将不能访问这个指针。 令const_iterator的成员为protected的，将允许从const_iterator继承的类具有访问这些成 员的权限，但是不允许其他的类访问。

在第34和35行是const_iterator的构造函数。该构造函数在List类的begin和end的实现中 用到。我们不希望所有的类都能访问这个构造函数（假定迭代器不能从指针变量显式构造），因 此该构造函数不可以是公有的，但是我们又希望iterator类可以访问它，因此，逻辑上说，这 个构造函数是被保护的。然而，这个保护没有提供List类访问这个构造函数的权限。解决的方案 是第37行的友元声明（friend declaration)。该声明允许List类访问const_iterator的非公有成

口

贝。

const—iterator的公有方法都使用操作符重载。operator--^ operator!=矛口operator* 是最直接的。在第10〜21行，可以看到operato:r++的实现。回想在语法上前缀和后缀版本的 〇Perat〇r++是完全不同的。因此，需要对不同的形式分别来编写例程。它们拥有相同的名字， 因此必须用不同的符号来区分。C++需要通过给前缀形式指定空参数表，给后缀形式指定一个（匿 名的）int参数来赋予如缀和后缀形式以不同的标识。然后，++itr调用零参数operator++;而