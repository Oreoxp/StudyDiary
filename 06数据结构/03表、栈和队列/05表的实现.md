## 表的实现

​		在本节中，提供了一个可用的 list 类模板的实现。和 vector 类中的情况一样，我们的表类还是命名为 XList 以避免与库类的混淆。

​		回顾一下，前面提到的 XList 类将要作为双向链表来实现，并且我们需要修改指向表两端的指针。只要操作是发生在已知位置，这样做就可以保证每个操作的时间消耗为常量。这个已知位置可以是末尾，也可以是迭代器指定的位置。

​		考虑到设计需要，我们需要提供下面的 4 个类：

1. List 类本身。包含连接到表两端的链接、表的大小以及一系列的方法。

2. Node 类。该类看起来像是私有的嵌套类。一个结点包含数据和用来指向其前和其后的结点的指针，以及适当的构造函数。

3. const_iterator 类。该类抽象了位置的概念，是一个公有的嵌套类。const_iterator 存储指向当前结点的指针，并且提供基本迭代器操作的实现，以及所有的重载操作符，例如 =、==、！=和++。

4. iterator 类。该类抽象了位置的概念，是一个公有的嵌套类。除了 operator* 操作返回所指向项的引用，而不是该项的常量引用的功能外，iterator 具有与 const_iterator 相同的功能。一个重要的技术点是 iterator 可以用于任何需要使用 const_iterator 的例程里，反之则不是。换句话说，iterator 就是 const_iterator。

​        因为迭代器类存储指向 “ 当前结点 ” 的指针，并且尾部标志是一个有效的位置，这使得在表的末尾添加一个额外的结点来作为尾部标志成为可能。进一步地，也可以在表的前端生成一个额外的结点，从而逻辑上作为开始标志。这些额外的结点有时被称为**哨兵结点**；特别地，在头部的结点有时候称为**表头结点（header node)**，而在末端的结点称为**尾结点（tail node)**。

​		使用这些额外结点的好处是可以去掉很多特例，这极大地简化了程序代码。例如，如果我们不使用表头结点，那么删除第一个结点将成为一个特例，因为我们必须在删除过程中重新设置表的链接到第一个结点上，而且删除算法一般来说也需要访问被删除结点前面的结点（没有表头结点，第一个结点前面就没有结点了）。图3-9是带有表头结点和尾结点的双向链表。图3-10是空双向链表。

![05具有表头节点和尾结点的双向链表](./markdowniamge/05具有表头节点和尾结点的双向链表.png)

![05具有表头节点和尾结点的空双向链表](./markdowniamge/05具有表头节点和尾结点的空双向链表.png)

图3-11和图3-12是List类的概要和部分实现。

![05list类](./markdowniamge/05list类.png)

​		观察第 5 行私有嵌套的 Node 类的声明的开始部分，可以看到这里使用了 struct 而不是使用 class 关键字。在 C++ 中 ，struct 是 C 编程语言遗留下来的产物。C++ 中的 struct 在本质上来说就是其成员默认为公有的class。回顾一下，在 class 中，其成员都是私有的。很明显，struct 关键字不是必需的，然而，还是经常可以看到程序员在声明一个大部分数据需要直接访问而不是使用方法来访问的类型时使用 struct 。在我们的例子中，令Node 类中的成员为 public 并不会成为什么问题，因为 Node 类本身是私有的并且不允许来自 List 类之外的访问。

