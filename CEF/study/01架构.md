[TOC]

​		CEF3 使用多个进程运行。处理窗口创建、绘制和网络访问的主要进程称为**浏览器进程**。这通常与宿主应用程序的进程相同，大多数应用程序的逻辑将在浏览器进程中运行。使用Blink引擎渲染HTML和JavaScript执行在单独的**渲染进程**中发生。一些应用程序逻辑（如JavaScript绑定和DOM访问）也将在渲染进程中运行。默认进程模型将为每个唯一源地址（scheme+domain）运行一个新的渲染进程。其他进程将根据需要生成，例如处理Flash等插件的**插件进程**和处理加速合成的**GPU进程**。综合上述文档，我们整理一下：

浏览器进程（Browser Process）：

- 窗口创建、绘制
- 网络访问
- ......

渲染进程（Renderer Process）：

- 通过Blink引擎渲染HTML
- JavaScript执行（V8引擎）
- ......

​        需要注意的是，**浏览器进程**中会进行窗口绘制，并不是指绘制HTML内容，而是承载网页内容的那个窗体壳，同样**渲染进程**也不是用来创建窗体的进程。接下来，将以官方CefSimple Demo源码入手，逐步介绍 CEF 的概念。

**<u>cefsimple_win.cc</u>**

```cpp
// ......
// Entry point function for all processes.
int APIENTRY wWinMain(HINSTANCE hInstance,
                      HINSTANCE hPrevInstance,
                      LPTSTR lpCmdLine,
                      int nCmdShow) {
// ......

  // CEF应用程序会创建多个子进程（渲染render，插件plugin，GPU处理，等等）但是会共用一个可执行程序。以下的函数会检查命令行并且，如果确认是一个子进程，那么会执行相关的逻辑。
  int exit_code = CefExecuteProcess(main_args, nullptr, sandbox_info);
  if (exit_code >= 0) {
    // The sub-process has completed so return here.
    return exit_code;
  }

// ......

  // SimpleApp implements application-level callbacks for the browser process.
  // It will create the first browser instance in OnContextInitialized() after
  // CEF has initialized.
  CefRefPtr<SimpleApp> app(new SimpleApp);

  // Initialize CEF.
  CefInitialize(main_args, settings, app.get(), sandbox_info);

  // Run the CEF message loop. This will block until CefQuitMessageLoop() is
  // called.
  CefRunMessageLoop();

  // Shut down CEF.
  CefShutdown();

  return 0;
}
```

```c++
///
// 该函数应当在应用程序的入口函数处被调用，用以执行一个子进程。它可以用于执行一个可执行程序来启动一个子进程，该可执行程序可以是当前的浏览器客户端可执行程序（默认行为）或是通过设置CefSettings.browser_subprocess_path指定路径的可执行程序。如果被调用用于浏览器进程（在启动命令行中没有"type"参数），该函数会立刻返回-1。如果被调用时识别为子进程，该函数将会阻塞直到子进程退出并且返回子进程退出的返回码。application参数可以为空（null）。windows_sandbox_info参数只能在Windows上使用或设置为NULL（详见cef_sandbox_win.h
///
/*--cef(api_hash_check,optional_param=application,
        optional_param=windows_sandbox_info)--*/
int CefExecuteProcess(const CefMainArgs& args,
                      CefRefPtr<CefApp> application,
                      void* windows_sandbox_info);
```

​		从 **CefExecuteProcess** 这个函数我们不难推断出，CEF 在以多进程架构下启动的时候，会多次启动自身可执行程序。启动的时候，会通过命令行参数传入某些标识，由 **CefExecuteProcess** 内部进行判断。如果是主进程，则该函数立刻返回 -1，程序会继续执行下去，那么后续继续运行的代码全部都运行在主进程中；如果是子进程（渲染进程等），那么该函数会阻塞住，直到子进程结束后，该函数会返回一个大于等于 0 的值，并在 main 函数直接返回，进而退出。

![img](https://pic3.zhimg.com/80/v2-a4263dd145a1fd6596037776feed12da_720w.webp)

对 CefExecuteProcess 分析就到这里，细节可以阅读[官方文档](https://link.zhihu.com/?target=https%3A//bitbucket.org/chromiumembedded/cef/wiki/GeneralUsage.md%23markdown-header-entry-point-function)，我们继续后续的代码分析：

```cpp
// SimpleApp implements application-level callbacks for the browser process.
  // It will create the first browser instance in OnContextInitialized() after
  // CEF has initialized.
  CefRefPtr<SimpleApp> app(new SimpleApp);
```

注释翻译如下

> SimpleApp实现了对于浏览器进程在应用级别的回调。该实例CEF初始化后（initialized），在OnContextInitialized中会创建第一个browser实例

查看 SimpleApp 的声明，发现该类继承了 CefApp：

```text
class SimpleApp : public CefApp, public CefBrowserProcessHandler {
 public:
  SimpleApp();
  ......
}
```

于是，我们迎来了第一个重要的类：CefApp。

### CefApp

​		CefApp 在官方文档中，就写了一句话介绍：

> The [CefApp](https://link.zhihu.com/?target=http%3A//magpcss.org/ceforum/apidocs3/projects/(default)/CefApp.html) interface provides access to process-specific callbacks.
> CefApp 接口提供了指定进程的回调访问。

​		一开始看到 CefApp 时，想到上面提到的CEF的多进程架构，结合后文还会提到的 CefClient，以为所谓CefApp 就是指浏览器进程，CefClient 就对应其他的进程（一个 App 对应多个 Client，多么的自然的理解），**然而这样错误的理解**，在阅读代码的时候走了很大的弯路。

​		首先，我们看一下 CefApp 的头文件声明：

```cpp
class CefApp : public virtual CefBaseRefCounted {
 public:
  virtual void OnBeforeCommandLineProcessing(
      const CefString& process_type,
      CefRefPtr<CefCommandLine> command_line) {}

  virtual void OnRegisterCustomSchemes(
      CefRawPtr<CefSchemeRegistrar> registrar) {}

  virtual CefRefPtr<CefResourceBundleHandler> GetResourceBundleHandler() {
    return nullptr;
  }

  virtual CefRefPtr<CefBrowserProcessHandler> GetBrowserProcessHandler() {
    return nullptr;
  }

  virtual CefRefPtr<CefRenderProcessHandler> GetRenderProcessHandler() {
    return nullptr;
  }
};
```

​		先看其中有两个本文讨论的重点方法：`GetBrowserProcessHandler`、`GetRenderProcessHandler`。它们的文档注释如下：

```cpp
///
// Return the handler for functionality specific to the browser process. This
// method is called on multiple threads in the browser process.
// 返回浏览器进程特定功能的处理程序。在浏览器进程中的多个线程上调用此方法。
///
virtual CefRefPtr<CefBrowserProcessHandler> GetBrowserProcessHandler()
///
// Return the handler for functionality specific to the render process. This
// method is called on the render process main thread.
// 返回渲染进程特定功能的处理程序。在渲染进程中的主线程上调用此方法。
///
virtual CefRefPtr<CefRenderProcessHandler> GetRenderProcessHandler()
```

​		看到这些注释可能会疑问：为什么注释中一会儿说在浏览器进程中一会儿又说在渲染进程中？难道这个类的实例还会在多个进程中使用吗？对也不对。这个类的实例确实会在浏览器进程和渲染进程中使用，但是我们又知道，两个进程之间的资源是不共享的，包括类实例，所以在浏览器进程运行的过程中，会使用到 CefApp 的某个实例化对象，而在渲染进程的运行过程中，又会使用到 CefApp 另一个实例化对象，它们都是 CefApp 子类的实例，但一定不是同一个实例对象。

​		我们可以这样理解：一个 CefApp 对应了一个进程，而一个进程可以是浏览器进程（Browser Process），可以是渲染进程（Renderer Process）。因此，CefApp 提供了 GetBrowserProcessHandler 和GetRendererProcessHandler 来分别在相关进程中获取对应的handler。

​		这两个方法的实现由我们来决定，即我们可以通过编程方式来返回handler，**但这两个方法不会由我们客户端代码进行调用**，而是CEF在运行过程中，由CEF在某个时刻来回调这两个方法。所以，这里虽然写了两个GetXXXProcessHandler，但在**浏览器进程**和**渲染进程**中只会**分别**调用GetBrowserProcessHandler和GetRendererProcessHandler。

​		按照程序运行的角度讲，当浏览器进程运行的时候，CEF框架就会在某个时候调用CefApp::GetBrowserProcessHandler获得由我们定义的BrowserProcessHandler实例，这个实例会在适当的时候调用它提供的一些方法（后文介绍有哪些方法）；当渲染进程运行的时候，CEF框架就会在某个时候调用CefApp::GetRendererProcessHandler得到我们定义的RendererProcessHandler实例，然后在适当的时候调用RenererProcessHandler中的一些方法（后文介绍有哪些方法）。

​		在cefsimple的示例代码中只有一个SimpleApp是继承的CefApp，这个类还继承了CefBrowserHandler，表明自身是同时也是CefBrowserHandler，这样实现的`GetBrowserProcessHandler`就返回自身。那么CEF是如何将我们的CefApp实例关联到CEF运行中的呢？

```cpp
// SimpleApp implements application-level callbacks for the browser process.
  // It will create the first browser instance in OnContextInitialized() after
  // CEF has initialized.
  CefRefPtr<SimpleApp> app(new SimpleApp);

  // Initialize CEF.
  CefInitialize(main_args, settings, app.get(), sandbox_info);
```

注意CefInitialize中的`app.get()`参数，就是将我们的CefApp关联到CEF的运行中的。那么，有些读者会有疑问，在示例代码中，只看到我们创建的SimpleApp类继承了CefApp，并通过`GetBrowserProcessHandler`返回自身来表明是一个浏览器进程的回调实例，并没有看到体现渲染进程的代码呢？确实，cefsimple作为helloworld级别的代码，没有体现这一点。在cefclient示例代码中（更高阶的CEF示例，也更复杂），你会看到：

![img](https://pic3.zhimg.com/80/v2-07e6cc7a76c713db7369d68e5095b23e_720w.webp)

上图是浏览器进程CefApp子类ClientAppBrowser（这里的”Client“是cefclient示例代码的“client”，请勿和下文的CefClient类混淆）。