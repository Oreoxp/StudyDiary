[TOC]

# 进程控制



## 函数 fork

​		一个现有的进程可以调用 fork 函数创建一个新进程。

`#include <unistd.h>`

`ptd_t   fork(void);`

​		fork 函数调用一次返回两次，一次在子进程返回 0，一次在父进程返回新建子进程ID。

​		子进程和父进程继续执行 fork 调用之后的指令。子进程是父进程的**<u>副本</u>**。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间部分。**<u>父进程和子进程共享正文段</u>**。



在fork函数后，子进程会<u>共享父进程打开的文件描述符</u>，并且偏移量保持一致：

![子进程与父进程的打开文件共享](.\markdownimage\子进程与父进程的打开文件共享.png)

​		这种情况下，如果父子进程写同一描述符指向的文件，没有同步的话，他们的输出就会混合。



## 函数 wait 和 waitpid

​		调用wait和waitpid的进程会发生什么：

- 如果其所有子进程都还在运行，则阻塞。
- 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。
- 如果它没有任何子进程，则立即出错返回，

​		这两个函数的区别如下：

- 在一个子进程终止前，wait使其调用者阻塞，而waitpid有一选项，可使调用者不阻塞。
- waitpid并不等待在其调用之后的第一个终止子进程，它由若干个选项，可以控制它所等待的进程。



















