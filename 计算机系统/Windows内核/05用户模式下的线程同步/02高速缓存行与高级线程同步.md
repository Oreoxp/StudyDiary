### 高速缓存行

如果想为装配有多处理器的机器构建高性能应用程序，那么应该注意高速缓存行[4]。当CPU从内存中读取一个字节的时候，它并不只是从内存中取回一个字节，而是取回一个高速缓存行。高速缓存行可能包含32字节（老式CPU），64字节，甚至是128字节（取决于CPU），它们始终都对齐到32字节边界，64字节边界，或128字节边界。高速缓存行存在的目的是为了提高性能。一般来说，应用程序会对一组相邻的字节进行操作。如果所有字节都在高速缓存中，那么CPU就不必访问内存总线，后者耗费的时间比前者耗费的时间要多得多。

 

但是，在多处理器环境中，高速缓存线使得对内存的更新变得更加困难。我们可以从下面的例子中看到这一点：

\1.    CPU1读取一个字节，这使得该字节以及与它相邻的字节被读到CPU1的高速缓存行中。

\2.    CPU2读取同一个字节，这使得该字节被读到CPU2的高速缓存行中。

\3.    CPU1对内存中的这个字节进行修改，这使得该字节被写入到CPU1的高速缓存行中。但这一信息还没有写回到内存。

\4.    CPU2再次读取同一个字节。由于该字节已经在CPU2的高速缓存行中，因此CPU2不需要再访问内存。但CPU2将无法看到该字节在内存中新的值。

 

这种情形非常糟糕。当然，CPU芯片的设计者非常清楚这个问题，并做了专门的设计来对它进行处理。明确地说，当一个CPU修改了高速缓存行中的一个字节时，机器中的其他CPU会收到通知，并使自己的高速缓存行作废。因此在刚才的情形中，当CPU1修改该字节的值时，CPU2的高速缓存就作废了。在第4步中，CPU1必须将它的高速缓存写回到内存中，CPU2必须重新访问内存来填满它的高速缓存行。我们可以看到，虽然高速缓存行能够提高性能，但在多处理器的机器上它们同样能够损伤性能。

 

这一切都意味着我们应该根据高速缓存行的大小来将应用程序的数据组织在一起，并将数据与缓存行的边界对齐。这样做的目的是为了确保不同的CPU能够各自访问不同的内存地址，而且这些地址不在同一个高速缓存行中。此外，我们应该把只读数据（或不经常读的数据）与可读写数据分别存放。我们还应该把差不多会在同一时间访问的数据组织在一起。

 

下面这个例子是一个设计得非常糟糕的数据结构：

 

```c++
struct CUSTINFO {

  DWORD   dwCustomerID;   // Mostly read-only

  int    nBalanceDue;    // Read-write

  wchar_t  szName[100];    // Mostly read-only

  FILETIME ftLastOrderDate;  // Read-write

};
```



确定CPU的高速缓存行的大小的最简单方法就是调用Win32的**GetLogicalProcessorInformation**函数。这个函数会返回一个**SYSTEM_LOGICAL_PROCESSOR_INFORMATION**结构数组。我们可以检查每个结构的Cache字段，该成员是一个**CACHE_DESCRIPTOR**结构，其中的**LineSize**字段表示CPU的高速缓存行的大小。一旦有了这一信息，我们就可以使用C/C++编译器的**__declspec(align(#))**指示符来对字段对齐加以控制。下面是刚才的结构经过改进后的版本：

```c++
#define CACHE_ALIGN 64

// Force each structure to be in a different cache line.

struct __declspec(align(CACHE_ALIGN)) CUSTINFO {

  DWORD   dwCustomerID;   // Mostly read-only

  wchar_t  szName[100];    // Mostly read-only

  // Force the following members to be in a different cache line.

  __declspec(align(CACHE_ALIGN))

  int nBalanceDue;      // Read-write

  FILETIME ftLastOrderDate;  // Read-write

};
```



有关如何使用__declspec(align(#))指示符的详细信息，请参阅http://msdn2.microsoft.com/en-us/library/83ythb65.aspx。

 

注意  最好是始终只让一个线程访问数据（函数参数和局部变量是确保这一点的最简单方式），或者始终只让一个CPU访问数据（使用线程关联[5]）。只要能做到其中任何一条，就可以完全避免高速缓存行的问题了。

### 高级线程同步

如果只需要以原子方式修改一个值，那么Interlocked系列函数非常好用，我们当然应该优先使用它们。但大多数实际的编程问题需要处理的数据结构往往要比一个简单的32位值或64位值复杂得多。为了能够以“原子”方式来访问复杂数据结构，我们必须超越Interlocked系列函数，转而使用Windows提供的一些其他特性。

 

前面一节强调了在配备单处理器的机器上不应该使用旋转锁，即使在配备多处理器的机器上，在使用旋转锁的时候也应该谨慎。原因很简单，浪费CPU时间是件非常糟糕的事情。因此，我们需要一种机制，它既能让线程等待共享资源的访问权，又不会浪费CPU时间。

 

当线程想要访问一个共享资源或者想要得到一些“特殊事件”的通知时，线程必须调用操作系统的一个函数，并将线程正在等待的东西作为参数传入。如果操作系统检测到资源已经可供使用了，或者特殊事件已经发生了，那么这个函数会立即返回，这样线程将仍然保持可调度状态。（线程可能并不会立即运行，它是可调度的，系统会根据前一章中描述的规则来给它分配CPU。）

 

如果无法取得对资源的访问权，或者特殊事件尚未发生，那么系统会将线程切换到等待状态，使线程变得不可调度，从而避免了让线程浪费CPU时间。当线程在等待的时候，系统会充当它的代理。系统会记住线程想要访问什么资源，当资源可供使用的时候，它会自动将线程唤醒——线程的执行与特殊事件是同步的。

 

实际情况是，大多数线程在大部分情况下都处于等待状态。当系统检测到所有线程都已经在等待状态中度过了好几分钟的时候，系统的电源管理器将会介入。

 

##### 需要避免使用的一种方法

如果没有同步对象，如果操作系统不能对特殊事件进行监测，那么线程将不得不使用下面介绍的技术来在自己和特殊事件之间进行同步。但是，由于操作系统内建了对线程同步的支持，因此我们在任何时候都不应该使用这种方法。

 

在这种方法中，两个线程共享一个变量，其中一个线程不断地读取变量的值，直到另一个线程完成它的任务为止。下面这段代码展示了这种方法：

 

```c++
volatile BOOL g_fFinishedCalculation = FALSE;

int WINAPI _tWinMain(...) {

  CreateThread(..., RecalcFunc, ...);

  ...

  // Wait for the recalculation to complete.

  while (!g_fFinishedCalculation)

     ;

  ...

}

DWORD WINAPI RecalcFunc(PVOID pvParam) {

  // Perform the recalculation.

  ...   g_fFinishedCalculation = TRUE;

  return(0);

}
```



 

正如我们所看到的那样，当主线程（执行_tWinMain）需要等待RecalcFunc函数完成的时候，它并没有让自己进入休眠状态。由于主线程没有进入休眠状态，因此CPU不断地给它调度CPU时间，这就从其他线程手中夺走了宝贵的CPU时间。

 

刚才这段代码还存在另一个问题，那就是BOOL变量g_fFinishedCalculation可能永远不会被设为TRUE。如果主线程的优先级比RecalcFunc函数所在线程的优先级高，那么就可能发生这种情况。在这种情况下，系统不会分配任何时间片给RecalcFunc所在线程，因此把g_fFinishedCalculation设为TRUE的语句永远不会执行。如果_tWinMain函数所在线程不进行轮询，而是进入休眠，那么系统就不必给它调度时间，从而有机会把时间调度给低优先级的线程，比如RecalcFunc所在线程，让它们得以执行。

 

不可否认的是轮循有时候还是非常方便的，毕竟旋转锁就是这么做的。但即便如此，也还是有正确的方式和不正确的方式。一个通用的规则是，我们既不应该使用旋转锁，也不应该进行轮循，而应该调用函数把线程切换到等待状态，直到线程想要访问的资源可供使用为止。我们会在下一节对正确的方式进行介绍。

 

首先，还有一点必须指出：在刚才那段代码的顶部，我们可以注意到使用了**volatile**关键字。为了使上面这段代码能够正常工作，**volatile**类型限定符是不可或缺的。它告诉编译器这个变量可能会被应用程序之外的其他东西修改，比如操作系统、硬件或者一个并发执行的线程。确切地说，**volatile**限定符告诉编译器不要对这个变量进行任何形式的优化，而是始终从变量在内存中的位置读取变量的值。现在假设编译器为刚才那段代码中的while循环生成了下面的伪代码：

 

```c++
MOV  Reg0, [g_fFinishedCalculation]  ; Copy the value into a register

Label: TEST Reg0, 0          ; Is the value 0?

JMP  Reg0 == 0, Label         ; The register is 0, try again

...                  ; The register is not 0 (end of loop)
```



如果不给布尔变量加上volatile限定符，编译器可能会对C++代码进行优化，就像这里显示的那样。在这个优化中，编译器把BOOL变量的值载入到CPU寄存器中，这个操作只需要进行一次。然后它重复对CPU寄存器中的值进行测试。与每次都从变量所在的内存地址取得变量的值并进行测试相比，这样做当然能够得到更好的性能。因此，一个编译器可能会把代码优化成刚才显示的这样。但是，如果编译器进行这样的优化，那么线程会陷入无限循环。顺便提一下，给一个结构加volatile限定符等于给结构中所有的成员都加volatile限定符，这样可以确保任何一个成员都始终是从内存中读取的。

 

读者可能会感到迷惑，那么（在前面旋转锁代码中用到的）旋转锁变量g_fResourceInUse是不是也应该声明为volatile呢？回答是否定的。这是因为我们传给Interlocked函数的是变量的地址，而不是变量的值。如果传一个变量的地址给函数，那么函数必须从内存中读取它的值，编译器的优化器不会对此产生影响。