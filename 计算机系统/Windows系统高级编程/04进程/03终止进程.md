## 终止进程

进程可以通过以下4种方式终止：

* 主线程的入口点函数返回 ( 强烈推荐的方式 ）

* 进程中的一个线程调用**ExitProcess**函数 ( 要避免这种方式 ） 

* 另一个进程中的线程调用 **TerminateProcess** 函数 ( 要避免这种方式 ）

* 进程中的所有线程都 “ 自然死亡 ”（ 这种情况几乎从来不会发生 ）

本节将讨论所有这4种方法，并描述进程终止时实际发生的情况。





### 1.主线程的入口点函数返回

​		设计一个应用程序时，应该保证只有在主线程的入口点函数返回之后，这个应用程序的进程才终止。只有这样，才能保证主线程的所有资源都被正确清理。

​		让主线程的入口点函数返回，可以保证以下操作会被执行。

* 该线程创建的任何 C++ 对象都将由这些对象的析构函数正确销毁。

* 操作系统将正确释放线程栈使用的内存。

* 系统将进程的退出代码 ( 在进程内核对象中维护 ) 设为入口点函数的返回值。

* 系统递减进程内核对象的使用计数。





### 2.ExitProcess 函数

​		进程会在该进程中的一个线程调用 **ExitProcess** 函数时终止：

```C
VOID ExitProcess(UINT fuExitCode);
```

​		该函数将终止进程，并将进程的退出代码设为**fuExHCode** ,  **ExitProcess**不会返回值，因为进程已经终止了。如果**ExitProcess**之后还有别的代码，那些代码永远不会执行。

​		当主线程的入口点函数 ( WinMain，wWinMain，main或wmain ) 返回时，会返回到C/C++ 运行库启动代码，后者将正确淸理进程使用的全部 C 运行时资源。释放了 C 运行时资源之 后，C 运行时启动代码将显式调用**ExitProcess**，并将入口点函数返回的值传给它。这便解释了为什么只需从主线程的入口点函数返回，就会终止整个进程。注意，进程中运行的其他任何线程都会随进程一起终止。

​		Windows Platform SDK文档指出，一个进程在其所有线程都终止之后才会终止。从操作系统的角度出发，这种说法是正确的。不过，C/C++运行库为应用程序采取了一个不同的策略：不管进程中是否还有其他线程在运行，只要应用程序的主线程从它的入口点函数返回 ,  C/C++ 运行库就会调用**ExitProcess**来终止进程。不过，如果在入口点函数中调用的是 **ExitThread** , 而不是调用**ExitProcess**或者入口点函数直接返回，应用程序的主线程将停止 执行，但只要进程中还有其他线程正在运行，进程就不会终止。

​		注意，调用**ExitProcess**或**ExitThread**会导致进程或线程直接终止运行-------再也不会返回当前函数调用。就操作系统而言，这样做是没有什么问题的，进程或线程的所有操作系统资源都会被正确清理。不过，C/C++应用程序应避免调用这些函数，因为C/C++运行库也许不能执行正确清理工作。下面来看看以下代码：

```c++
#include <windows.h> 
#include <stdio.h>

class CSomeObj { 
    public：
	CSomeObj() { printf("Constructor \r\n"); }
	~CSomeObj() { printf{"Destructor \r\n")； }
};
    
CSomeObj g_GlobalObj;
    
void main ()(
	CSomeObj LocalObj;
	ExitProcess (0); // This shouldn't: be here
    
	// At the end of this function, the compiler automatically added 
    // the code necessary to call LocalObj's destructor.
	// ExitProess prevents it from executing.
}
```

执行上述代码，会显示以下结果:

`Constructor`
`Constructor`

​		它构造了两个对象，一个是全局对象，另一个是本地对象。“ Destructor ” 字样永远都不会显示。C++对象没有被正确析构，因为**ExitProcess**造成进程 “ 当场终止运行 ”  ：C/C++ 运行时没有机会执行清理工作。

​		就像我说的那样，任何时候都不要显式地调用**ExitProcess**。在前面的代码中删除对 **ExitProcess** 函数的调用，再运行这个程序就会得到以下结果：

`Constructor`

`Constructor`

`Destructor`

`Destructor`

​		只需从主线程的入口点函数返回，C/C++ 运行时就能执行其清理工作，并正确析构所有 C++ 对象。顺便提一下，这里的讨论并不只适用于 C++ 对象。C/C++运行时代表进程做了许多事情；最好允许运行时正确地完成清理工作。

说明		许多应用程序之所以无法正确清理自己，是因为显式调用了 **ExitProcess**和 **ExitThread**。在**ExitThread**的情况下，进程会继续运行，但可能泄漏内存或其他资源。





### 3.TerminateProcess 函数

​		调用**TerminateProcess**也可以终止一个进程，如下所示：

```c
BOOL TerminateProcess(
    HANDLE hProcess,
    UINT fuExitCode
);
```

​		此函数与**ExitProcess**函数有一个明显的区别：任何线程都可以调用**TerminateProcess**来终止另一个进程或者它自己的进程。**hProcess**参数指定了要终止的进程的句柄。进程终止时，其退出代码的值就是传给**fuExitCode**参数的值。

​		只有在无法通过其他方法来强制进程退出时，才应使用**TerminateProcess**被终止的进程得不到自己要被终止的通知一一应用程序不能正确清理，也不能阻止它自己被强行终止 ( 除非通过正常的安全机制 ) 。例如，在这种情况下，进程无法将它在内存中的任何信息刷 ( flush ) 到磁盘上。

​		虽然进程没有机会执行自己的淸理工作，但操作系统会在进程终止之后彻底进行清理，确保不会泄漏任何操作系统资源。这意味着进程使用的所有内存都会被释放，所有打开的文件都会被关闭，所有内核对象的使用计数都将递减，所有的用户对象和 GDI 对象都会被销毁。

​		一旦进程终止 ( 不管是如何终止的 ) ，系统会保证不留它的任何部分。绝对没有任何办法知道那个进程是否运行过。**进程在终止后绝对不会泄漏任何东西**。希望大家都己经明确这一点了



说明		TerminateProcess函数是**异步的** ，换言之，它告诉系统我们希望进程终止，但到函数返回的时候，系统并不能保证进程已经被强行终止了。所以，为了确定进程是否 已经终止，应该调用**WaitForSingleObject**(详见第9章)或者一个类似的函数，并将进程的句柄传给它。



### 4.当进程中的所有线程终止时

​		如果一个进程中的所有线程都终止了(要么是因为它们都调用了 **ExitThread**，要么是因为它 们都用**TerminateThread**来终止了 ) ，操作系统就认为没有任何理由再保持进程的地址空间。这是非常合理的，因为没有线程在执行地址空间中的任何代码。一旦系统检测到一个 进程中没有任何线程在运行，就会终止这个进程。进程的退出代码会被设为最后一个终止 的那个线程的退出代码。





### 5.当进程终止运行时

​		一个进程终止时，系统会依次执行以下操作。

**(1)** 终止进程中遗留的任何线程。

**(2)** 释放进程分配的所有用户对象和 GDI 对象，关闭所有内核对象 ( 如果没有其他进程打开这些内核对象的句柄，那么它们也会被销毁。不过，如果其他进程打开了它们的句柄， 那么它们就不会被销毁)。

**(3)** 进程的退出代码从 **STILL_ACTIVE** 变为传给**ExitProcess**或**TerminateProcess**函数的代码。

**(4)** 进程内核对象的状态变成已触发状态，（ 关于信号机制的详情，请参见第 9 章 )。这就 是为什么系统中的其他线程可以挂起它们自己，直至另一个进程终止运行。

**(5)** 进程内核对象的使用计数递减 1 。

​		注意，进程内核对象的生命期至少能像进程本身一样长。但是，**进程内核对象存活的时间也许比进程本身存活的时间更久**。一个进程终止时，系统会自动递减其内核对象的使用计数。如果计数减至 0 , 表明没有其他进程打开了这个对象的句柄，所以在进程被销毁时， 对象也会被销毁。

​		但是，当一个进程终止的时候如果系统中还有另一个进程打开了这个进程的内核对象的句柄，那么进程内核对象的使用计数就不会变成 0 。当父进程忘记关闭到它的一个子进程的句柄时，往往会发生这种情况。这是Windows 的一个特性(或功能)，而不是 bug 。记住， 进程内核对象会维护与进程有关的统计信息。即使是在进程终止之后，这些信息也可能有用。例如，我们可能想知道一个进程需要多少 CPU 时间。或者，一个更有可能的原因是， 我们想通过调用**GetExitCodeProcess**来获得己经终止的一个进程的退出代码：

```c
BOOL GetExitCodeProcess(
    HANDLE hProcess,
    PDWORD pdwExitCode
);
```

​		该函数会査找进程内核对象 ( 由 **hProcess** 数标识)，并从内核对象的数据结构中提取用于标识进程退出代码的成员。退出代码的值在 **pdwExitCode** 参数指向的一个 **DWORD** 中返回。

任何时候都可以调用这个函数。如果在调用GetExitCodeProcess的时候进程还没有终止， 函数将用ST1LL_ACTIVE标识符(定义为0x103)来填充DWORD。如果进程已经终止，就 返回实际的退出代码值。

有人可能会想，我是不是可以编写代码，定期调用GetExitCodeProcess并检査退出代码， 从而判断一个进程是否终止？虽然这在很多情况下都是行得通的，但其效率不敢恭维。下 一节将介绍如何通过正确的方式来判断进程是在什么时候终止的。

再次重申，应该凋用CloseHandle来告诉操作系统我们已经对进程中的统计数据不感兴趣 了。如果进程已经终止，CioseHandle函数将递减内核对象的使用计数，并释放它。