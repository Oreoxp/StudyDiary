## 循环展开

​		循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。 psum2 函数（见图5-1)就是这样一个例子，其中每次迭代计算前置和的两个元素，因而将需要的迭代次数减半。循环展开能够从两个方面改进程序的性能。首先，它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。第二，它提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。在本节中，我们会看一些简单的循环展开，不做任何进一步的变化。

![02前置和函数](.\markdowniamge\02前置和函数.png)

​		图5-16是合并代码的使用 “ 2 X 1 循环展开 ” 的版本。第一个循环每次处理数组的两个元素。也就是每次迭代，循环索引 i 加 2 ,在一次迭代中，对数组元素 i 和 i + 1 使用合并运算。

​		一般来说，向量长度不一定是 2 的倍数。想要使我们的代码对任意向量长度都能正确工作，可以从两个方面来解释这个需求。首先，要确保第一次循环不会超出数组的界限。 对于长度为 72 的向量，我们将循环界限设为 72 - 1 。然后，保证只有当循环索引 i 满足  i < n — 1 时才会执行这个循环，因此最大数组索引 i + 1 满足 i + 1 < ( n — 1 ) + 1  = n 。

​		把这个思想归纳为对一个循环按任意因子 k 进行展开，由此产生 k X 1 循环展开。为此， 上限设为 n - k +1 ，在循环内对元素 i 到 i + k - 1 应用合并运算。每次迭代，循环索引 i 加 k 。 那么最大循环索引 i + k 一 1 会小于 n 。要使用第二个循环，以每次处理一个元素的方式处理向量的最后几个元素。这个循环体将会执行 0 〜 k 一 1次。对于 k = 2,我们能用一个简单的条件语句，可选地增加最后一次迭代，如函数 psum2 (图5-1)所示。对于 k > 2 ,最后的这些情况最好用一个循环来表示，所以对 k = 2 的情况，我们同样也采用这个编程惯例。我们称这种变换为“ **k X 1 循环展开**”，因为循环展开因子为 k ,而累积值只在单个变量 acc 中。

![08使用2X1循环展开](.\markdowniamge\08使用2X1循环展开.png)

​		修改combine5的代码，展开循环是 k = 5 次。
​		当测量展开次数 k = 2(combine5) 和 k = 3 的展开代码的性能时，得到下面的结果:

![08公式1](.\markdowniamge\08公式1.png)

​		我们看到对于整数加法，CPE 有所改进，得到的延迟界限为 1.00。会有这样的结果是得益于减少了循环开销操作。相对于计算向量和所需要的加法数量，降低开销操作的数量，此时，整数加法的一个周期的延迟成为了限制性能的因素。另一方面，其他情况并没有性能提高——它们已经达到了其延迟界限。图5-17给出了当循环展开到10 次时的 CPE 测量值。对于展开 2 次和 3 次时观察到的趋势还在继续——没有一个低于其延迟界限。

​		要理解为什么 k X 1 循环展开不能将性能改进到超过延迟界限，让我们来查看一下是 k = 2 时，combine5 内循环的机器级代码。当类型 data_t 为 double，操作为乘法时，生成如下代码

```assembly
Inner loop of combine5. data_t » double, OP = * 
i in %rdx, data %rax, limit in %rbp, acc ia %xmm0

1 .L35:										loop：
2	vmulsd (%rax，%rdx，8)，%xmm0, %xmm0		Multiply acc by data[i]
3	vmulsd 8(%rax，%rdx，8) , %xmm0, %xmmO	Multiply acc by data[i+1]
4	addq	$2, %rdx							Increment i by 2
5	cmpq	%rdx, %rbp							Compare to limit:i
6	jg	.L35									If >, goto loop
```

![08不同程度kX1循环展开的CPE性能](.\markdowniamge\08不同程度kX1循环展开的CPE性能.png)

​		我们可以看到，相比 combine4 生成的基于指针的代码，GCC 使用了 C 代码中数组引用的更加直接的转换。循环索引 i 在寄存器 %rdx 中，data 的地址在寄存器 ％rax 中，和前面一样，累积值 acc 在向量寄存器 ％xmm0 中。循环展开会导致两条 vmulsd 指令——一条将 data[i] 加到 acc 上，第二条将 data[i+1] 加到 acc 上。图5-18给出了这段代码的图形化表示。每条 vmulsd 指令被翻译成两个操作：一个操作是从内存中加载一个数组元素，另一个是把这个值乘以已有的累积值。

​		这里我们看到，循环的每次执行中，对寄存器 ％xmm0 读和写两次。可以重新排列、简化和抽象这张图，按照图5-19a所示的过程得到 图5-19b所示的模板。然后，把这个模板复制 n/2 次，给出一个长度为 n 的向量的计算, 得到如图5-20所示的数据流表示。在此我们看到，这张图中关键路径还是 n 个 mul 操 作——迭代次数减半了，但是每次迭代中还是有两个顺序的乘法操作。这个关键路径是循环没有展开代码的性能制约因素，而它仍然是 k X 1循环展开代码的性能制约因素。

![08combine5内循环代码的图形化表示](.\markdowniamge\08combine5内循环代码的图形化表示.png)

![08将combine5的操作抽象成数据流程图](.\markdowniamge\08将combine5的操作抽象成数据流程图.png)