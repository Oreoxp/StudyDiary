## 消除不必要的内存引用

​		combine3 的代码将合并运算计算的值累积在指针 dest 指定的位置。通过检查编译 出来的为内循环产生的汇编代码，可以看出这个属性。在此我们给出数据类型为 double , 合并运算为乘法的 x86-64 代码：

```assembly
;Inner loop of combine3. data_t = double, OP = * 
;dest in %rbx, data+i in %rdx, data+length in %rax
1 .L17:								;loop:
2	vmovsd	(%rbx) , %xmm0				;Read product from dest
3	vmulsd	(%rdx) , %xmm0, %xmm0		;Multiply product by data[i]
4	vmovsd	%xmm0,(%rbx)				;Store product at dest
5	addq	$8, %rdx					;Increment data+i
6	cmpq	%rax, %rdx					;Compare to data+length
7	jne	.L17							;If !=, goto loop
```


​		在这段循环代码中，我们看到，指针 dest 的地址存放在寄存器 ％rbx 中，它还改变了代码，将第 i 个数据元素的指针保存在寄存器 ％rdx 中，注释中显示力 data+i 。每次迭代，这个指针都加 8 。循环终止操作通过比较这个指针与保存在寄存器 ％rax 中的数值来判断。我们可以看到每次迭代时，累积变量的数值都要从内存读出再写入到内存。这样的读写很浪费，因为每次迭代开始时从 dest 读出的值就是上次迭代最后写入的值。

​		我们能够消除这种不必要的内存读写，按照图5-10中 combine 所示的方式重写代码。引人一个临时变量 acc ，它在循环中用来累积计算出来的值。只有在循环完成之后结果才存放在 dest 中。正如下面的汇编代码所示，编译器现在可以用寄存器 ％xmm0 来保存累积值。与 combine3 中的循环相比，我们将每次迭代的内存操作从两次读和一次写减少到只需要一次读。

![05把结果累计在临时变量中](.\markdowniamge\05把结果累计在临时变量中.png)

我们看到程序性能有了显著的提高，如下表所示：

![05公式2](.\markdowniamge\05公式2.png)

所有的时间改进范围从 2. 2X 到 5. 7X  ,整数加法情况的时间下降到了每元素只需 1. 27 个时钟周期。

​		可能又有人会认为编译器应该能够自动将图5-9中所示的 combine3 的代码转换为在寄存器中累积那个值，就像图5-10中所示的 combine 的代码所做的那样。然而实际上，由于内存别名使用，两个函数可能会有不同的行为。例如，考虑整数数据，运算为乘法，标识元素为 1 的情况。设 v = [2, 3, 5] 是一个由3个元素组成的向量，考虑下面两个函数调用：

 `combine3(v, get_vec_start(v) + 2);
 combine4(v, get_vec_start(v) +2);`
也就是在向量最后一个元素和存放结果的目标之间创建一个别名。那么，这两个函数的执行如下：

![05公式3](.\markdowniamge\05公式3.png)

​		正如前面讲到过的，combine3 将它的结果累积在目标位置中，在本例中，目标位置就是向量的最后一个元素。因此，这个值首先被设置为 1 ,然后设为 2*1  = 2,然后设为 3-2 = 6。最后一次迭代中，这个值会乘以它自己，得到最后结果 36 。对于 combine4 的情况来说，直到最后向量都保持不变，结束之前，最后一个元素会被设置为计算出来的值 1 • 2 • 3 • 5 = 30。

​		当然，我们说明 combine3 和 combine4 之间差別的例子是人为设计的。有人会说 combine的行为更加符合函数描述的意图。不幸的是，编译器不能判断函数会在什么情 况下被调用，以及程序员的本意可能是什么。取而代之，在编译C〇mbine3时，保守的方 法是不断地读和写内存，即使这样做效率不太高。

​		使用了这最后的变换，至此，对于每个元素的计算，都只需要1.25〜5个时钟周期。 比起最开始采用优化时的9〜11个周期，这是相当大的提高了。现在我们想看看是什么因 素在制约着代码的性能，以及可以如何进一步提高。