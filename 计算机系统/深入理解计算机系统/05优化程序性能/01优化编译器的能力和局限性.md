## 优化编译器的能力和局限性

​		现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是被如何使用的。然后会利用一些机会来简化表达式，在几个不同的地方使用同一个计算，以及降低一个给定的计算必须被执行的次数。大多数编译器，包括 GCC ,向用户提供了一些对它们所使用的优化的控制。就像在第3章中讨论过的，最简单的控制就是指定**优化级别**。例如，以命令行选项 “ -Og ” 调用 GCC 是让 GCC 使用一组基本的优化。以选项 01”或更高（如“-02”或“-03”)调用GCC会让它使用更大量的优化。这样做可以进一步提高程序的性能，但是也可能增加程序的规模，也可能使标准的调试工具更难对程序进行调试。我们的表述，虽然对于大多数使用 GCC 的软件项目来说，优化级别 -02 已经成为了被接受的标准，但是还是主要考虑以优化级别 -01 编译出的代码。我们特意限制了优化 级别，以展示写 C 语言函数的不同方法如何影响编译器产生代码的效率。我们会发现可以写出的 C 代码，即使用 -01 选项编译得到的性能，也比用可能的最高的优化等级编译一个更原始的版本得到的性能好。

​		编译器必须很小心地对程序只使用安全的优化，也就是说对于程序可能遇到的所有可能的情况，在 C 语言标准提供的保证之下，优化后得到的程序和未优化的版本有一样的行为。限制编译器只进行安全的优化，消除了造成不希望的运行时行为的一些可能的原因， 但是这也意味着程序员必须花费更大的力气写出编译器能够将之转换成有效机器代码的程序。为了理解决定一种程序转换是否安全的难度，让我们来看看下面这两个过程

```c
1	void twiddle1(long *xp, long *yp)
2	{
3		*xp	+=	*yp;
4		*xp	+=	*yp;
5	}
6
7	void twiddle2(long *xp, long *yp)
8	{
9		*xp	+=	2* *yp;
l0  }
```

​		乍一看，这两个过程似乎有相同的行为。它们都是将存储在由指针 yp 指示的位置处 的值两次加到指针 xp 指示的位置处的值。另一方面，函数 twiddle2 效率更高一些。它只要求3次内存引用（读* xp,读* yp，写* xp)，而twiddle1 需要 6 次(2次读* xp，2 次读 * yp，2 次写* xp)。因此，如果要编译器编译过程 twiddle1，我们会认为基于 twiddle2 执行的计算能产生更有效的代码。

​		不过，考虑 xp 等于 yp 的情况。此时，函数 twiddle1 会执行下面的计算：

```c
3	*xp += *xp; /* Double value at xp */
4	*xp += *xp; /* Double value at xp */
```

结果是 xp 的值增加4倍。另一方面，函数 twiddle2 会执行下面的计算：

```c
9	*xp += 2* *xp; /* Triple value xp */
```

结果是 xp 的值增加3倍。编译器不知道 twiddle1 会如何被调用，因此它必须假设参数 xp 和 yp 可能会相等。因此，它不能产生 twiddle2 风格的代码作为 twiddle1 的优化版本。

​		这种两个指针可能指向同一个内存位置的情况称为**内存别名使用（memory abasing)**。 在只执行安全的优化中，编译器必须假设不同的指针可能会指向内存中同一个位置。再看一个例子，对于一个使用指针变量 p  和 q  的程序，考虑下面的代码序列：

```c
 x = 1000; y = 3000;
*q = y; 	/* 3000 */
*p = x; 	/* 1000 */
t1 = *q;	/* 1000 or 3000 */
```

t1 的计算值依赖于指针 p 和 q 是否指向内存中同一个位置——如果不是，t1 就等于 3000,但如果是，t1 就等于1000。这造成了一个主要的妨碍优化的因素，这也是可能严重限制编译器产生优化代码机会的程序的一个方面。如果编译器不能确定两个指针是否指向同一个位置，就必须假设什么情况都有可能，这就限制了可能的优化策略。

​		如果调用这个过程时xP等于yp，会有什么样的效果？
​		第二个妨碍优化的因素是函数调用。作为一个示例，考虑下面这两个过程:

```c
1	long f();
2
3	long func1() {
4		return f() + f() + f() + f();
5	}
6
7	long func2() {
8		return 4*f();
9	}
```

​		最初看上去两个过程计算的都是相同的结果，但是 func2 只调用 f 一次，而 fun1 调用 f 四次。以 func1 作为源代码时，会很想产生 func2 风格的代码。

不过，考虑下面f的代码：

```c
1	long counter = 0;
2
3	long f() {
4		return counter++;
5	}
```

​		这个函数有个副作用——它修改了全局程序状态的一部分。改变调用它的次数会改变程序的行为。特别地，假设开始时全局变量 counter 都设置为 0 ,对 func1 的调用会返回 0 + 1 + 2 + 3 = 6，而对 func2 的调用会返回4 x 0 = 0。

​		大多数编译器不会试图判断一个函数是否没有副作用，如果没有，就可能被优化成像  func2 中的样子。相反，编译器会假设最糟的情况，并保持所有的函数调用不变。

​		在各种编译器中，就优化能力来说，GCC 被认为是胜任的，但是并不是特别突出。 它完成基本的优化，但是它不会对程序进行更加 “ 有进取心的 ” 编译器所做的那种激进变换。因此，使用 GCC 的程序员必须花费更多的精力，以一种简化编译器生成高效代码的任务方式来编写程序。