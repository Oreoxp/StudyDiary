### 用RIO包健壮地读写

​		在这一小节里，我们会讲述一个 I/O 包，称为 **RIO ( Robust I/O,健壮的 I/O )** 包，它会自动为你处理上文中所述的不足值。在像网络程序这样容易出现不足值的应用中，RIO 包提供了方便、健壮和高效的 I/O。RIO 提供了两类不同的函数：

* **无缓冲的输入输出函数**。这些函数直接在内存和文件之间传送数据，没有应用级缓冲。它们对将二进制数据读写到网络和从网络读写二进制数据尤其有用。

* **带缓冲的输入函数**。这些函数允许你高效地从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内，类似于为 printf 这样的标准 I/O 函数提供的缓冲区。与 [110] 中讲述的带缓冲的 I/O 例程不同，带缓冲的 RIO 输入函数是线程安全的（12. 7.1节），它在同一个描述符上可以被交错地调用。例如，你可以从一个描述符中读一些文本行，然后读取一些二进制数据，接着再多读取一些文本行。

​        我们讲述 RIO 例程有两个原因。第一，在接下来的两章中，我们开发的网络应用中使用了它们；第二，通过学习这些例程的代码，你将从总体上对 Unix I/O 有更深入的了解。 



#### RIO 的无缓冲的输入输出函数

​		通过调用 rio_readn 和 rio_writen 函数，应用程序可以在内存和文件之间直接传送数据。

![05公式1](./markdownimage/05公式1.png)

​		rio_readn 函数从描述符 fd 的当前文件位置最多传送 n 个字节到内存位置 usrbuf 。 类似地，rio_writen 函数从位置 usrbuf 传送 n 个字节到描述符 fd 。rio_read 函数在遇到 EOF 时只能返回一个不足值。rio_writen 函数决不会返回不足值。对同一个描述符， 可以任意交错地调用 rio_readn 和 rio_writen 。

​		图 10-4 显示了 rio_readn 和 rio_writen 的代码。注意，如果 rio_readn 和 rio_writen 函数被一个从应用信号处理程序的返回中断，那么每个函数都会手动地重启 read 和 write 。为了尽可能有较好的可移植性，我们允许被中断的系统调用，且在必要时重启它们。

![05rio_readn和rio_writen函数](./markdownimage/05rio_readn和rio_writen函数.png)





### RIO的带缓冲的输入函数

​		假设我们要编写一个程序来计算文本文件中文本行的数量，该如何来实现呢？ 一种方法就是用 read 函数来一次一个字节地从文件传送到用户内存，检查每个字节来查找换行符。这个方法的缺点是效率不是很高，每读取文件中的一个字节都要求陷入内核。

​		—种更好的方法是调用一个包装函数（rio_readlineb）,它从一个内部读 **缓冲区** 复制一个文本行，当缓冲区变空时，会自动地调用 read 重新填满缓冲区。对于既包含文本行也包含二进制数据的文件(例如11. 5. 3节中描述的HTTP响应），我们也提供了一个 rio_readn 带缓冲区的版本，叫做 rio_readnb，它从和 rio_readlineb —样的读缓冲区中传送原始字节。

![05公式2](./markdownimage/05公式2.png)

​		每打开一个描述符，都会调用一次 rio_readinitb 函数。它将描述符 fd 和地址 rp 处的一个类型为 rio_t 的读缓冲区联系起来。

​		rio_readlineb 函数从文件 rp 读出下一个文本行（包括结尾的换行符），将它复制到内存位置usrbuf，并且用 NULL (零）字符来结束这个文本行。rio_readlineb 函数最多读 maxlen-1 个字节，余下的一个字符留给结尾的NULL 字符。超过 maxlen-1 字节的文本行被截断，并用一个 NULL 字符结束。

​		rio_readnb 函数从文件 rp 最多读 n 个字节到内存位置 usrbuf 。对同一描述符，对 rio_readlineb 和rio_readnb 的调用可以任意交叉进行。然而，对这些带缓冲的函数的调用却不应和无缓冲的 rio_readn 函数交叉使用。

​		在本书剩下的部分中将给出大量的 RIO 函数的示例。图10-5展示了如何使用 RIO 函数来一次一行地从标准输入复制一个文本文件到标准输出。

![05一个文本文件到标准输出](./markdownimage/05一个文本文件到标准输出.png)

​		图10-6展示了一个读缓冲区的格式，以及初始化它的 rio_readinitb 函数的代码。 rio_readinitb 函数创建了一个空的读缓冲区，并且将一个打开的文件描述符和这个缓冲区联系起来。

![05一个类型为rio_t的读缓存区和初始化它的rio_readinit函数](./markdownimage/05一个类型为rio_t的读缓存区和初始化它的rio_readinit函数.png)

​		RIO 读程序的核心是图10-7所示的 rio_read 函数。rio_read 函数是 Linux read 函数的带缓冲的版本。当调用rio_read 要求读 n 个字节时，读缓冲区内有 rp->rio_cnt 个未读字节。如果缓冲区为空，那么会通过调用 read 再填满它。这个 read 调用收到一个不足值并不是错误，只不过读缓冲区是填充了一部分。一旦缓冲区非空，rio_read 就从读缓冲区复制 n 和 rp->rio_cnt 中较小值个字节到用户缓冲区，并返回复制的字节数。

![05内部的rio_read函数](./markdownimage/05内部的rio_read函数.png)

​		对于一个应用程序，rio_read 函数和 Linux read 函数有同样的语义。在出错时，它返回值 -1，并且适当地设置 errno 。在 EOF 时，它返回值 0 。如果要求的字节数超过了读缓冲区内未读的字节的数量，它会返回一个不足值。两个函数的相似性使得很容易通过用 rio_read 代替 read 来创建不同类型的带缓冲的读函数。例如，用rio_read 代替 read，图10-8中的rio_readnb 函数和 rio_readn 有相同的结构。相似地，图10-8中的 rio_readlineb 程序最多调用 maxlen-1 次 rio_read 。每次调用都从读缓冲区返回一个字节，然后检查这个字节是否是结尾的换行符。

![05rio_readlineb和rio_readnb](./markdownimage/05rio_readlineb和rio_readnb.png)