



[TOC]



## 调试器功能

### 1、控制被调试程序执行

1. 将被调试程序中断到调试器(Break into Debugger),典型的做法是在被调试程序中触发一个调试事件使其中断到调试器。很多调试器都有**<u>Break命令</u>**来支持这一功能。

2. 让被调试程序以受控的方式执行，比如单步执行，单步执行到指定位置，从指定的位置开始执行等。
3. 对 线程执行挂起(Suspend) /恢复(Resume)和冻结(Freeze) /解冻(Unfreeze)操作，比如**<u>WinDBG的~m、~n、~f 和~u命令可以对一个或多个线程分别执行挂起、恢复冻结和解冻操作。</u>**
4. 恢复被调试程序运行。
5. 终止被调试进程。
6. 重新启动(Restart) 被调试程序和调试会话，比如**<u>WinDBG的.restart命令可以重新运行被调试程序，内核调试中的.reboot命令可以让目标系统重新启动。</u>**

### 2、访问内存

可细分为：

1. 以不同格式显示内存中的数据，比如**<u>按字节、字、双字、字符串或结构类型(Type)来显示某一地址的数据。WinDBG的d系列命令用来实现这一功能。</u>**
2. **<u>编辑指定地址的内存数据，比如WinDBG的e系列命令</u>**。
3. 通过变量名来观察和修改它的取值，变量包括局部变量、全局变量、成员和静态变量等。
4. 移动(Move)某一范围的内存数据到另一位置。
5. 填充(Fill) 某一内存区域。.
6. 比较指定范围的内存数据。
7. 在内存中搜索某-一个数据模式。
8. 观察用来组织内存 的数据结构，比如堆(Heap) 和栈(Stack)。 **<u>WinDBG 的 !heap 和 !teb 扩展命令分别可以显示堆和栈的信息。</u>**

​        好的调试器应该允许用户以多种方式来指定要访问的内存地址，包括物理地址、虚拟地址、变量名称和表达式。

### 3、访问寄存器

​		访问寄存器功能用来观察或修改 CPU/寄存器。		这里要说明的一点是，因为一个 CPU ( 多核中的一个核 ) 只有一套寄存器，所以在调试器中观察到的寄存器都是**<u>上下文结构( CONTEXT )</u>** 中的寄存器。当调试事件发生时，系统会将当时的寄存器状态保存在一个执行上下文结构中，调试器中操作的都是这个 CONTEXT 结构中的值。当被调试程序被恢复执行时,系统会将 CONTEXT 结构中的寄存器值更新到 CPU 的物理寄存器中。**<u>出于这个原因，对寄存器的修改是在恢复程序运行时才生效的，而对于内存的修改是执行命令后便写到内存中的。</u>**

​		因为上下文结构中不包含 MSR 寄存器，所以对 MSR 寄存器的访问是直接针对 CPU 中的物理寄存器的，比如 **<u>WinDBG 的rdmsr 和 wrmsr 分别用来读写MSR寄存器。</u>**

​		包括 VC6 在内的很多调试器只提供观察寄存器的功能，不提供修改功能。但是 VC8 和 WinDBG 都有修改寄存器的功能(使用 r 命令)。特别是，修改程序指针寄存器(如r eip = 0xxx )的值可以起到跳转执行的目的，但使用时应该慎重，因为这种跳转可能导致栈失去平衡或变量未初始化等各种问题。

### 4、断点

​		设置和管理断点是调试器的最重要功能之一。设置断点的目的是让被调试程序执行到某一空间或时间点时将其中断到调试器中，然后对其进行分析。根据断点的中断条件可以将其分为如下几种。

1. 指令断点:当程序执行指定内存地址的指令时中断到调试器，又叫代码断点。
2. 数据断点:当程序访问指定内存地址的数据时中断到调试器。
3. I/O断点:当程序访问指定1/O地址的端口时中断到调试器。

​        **<u>对于 x86 CPU, INT 3 指令(机器码为 0xCC )专门是为实现代码断点而设计的，因此运行在x86 CPU.上的调试器通常都使用INT3指令来设置代码断点。</u>**

​		在断点被触发后(又称为命中，Hit)， 操作系统的调试子系统或调试器的接收例程会**保存程序的状态**，并利用操作系统的进程/线程管理功能**将被调试程序挂起**，然后将断点事件发送给调试器的**断点处理模块**。断点处理模块得到通知后，会根据断点的属性和调试器的设置决定是否需要通知用户并与用户交互，如果需要，则通过人机交互接口把控制权交给用户。在用户分析结束后再发出命令恢复继续执行。

### 5、观察栈和栈回溯

​		栈是程序执行的重要数据结构，是函数调用和分配局部变量所必不可少的特殊内存区。调试器通常提供如下几种观察栈的功能。
1. 显示栈的基本信息，包括栈的基地址、限制、当前栈顶地址(ESP)等。
2. 显示栈帧(Stack Frame)的信息，包括栈帧的基准地址(EBP)、 栈帧中的函数返回地址、参数和局部变量。显示局部变量的名称和取值，需要调试符号的支持,如果没有调试符号，那么只能以原始数据的形式来显示栈中的变量。
3. 栈回溯 (Stack Backtrace), 又叫打印函数调用序列(Calling Stack),即显示记录在栈中的函数调用过程。通过栈回溯可以了解程序的执行过程，因此对软件调试有着非常重要的意义。要显示正确的栈回溯信息也需要调试符号的帮助。

### 6、汇编和反汇编

​		汇编(Assemble) 功能是**<u>将一段汇编程序编译为机器码并写到指定的内存地址。比如 WinDBG 的 a 命令。</u>**反汇编是将某一地址范围的**<u>机器指令翻译为可读的汇编程序代码。WinDBG 的u和uf命令都是用来反汇编的</u>**。关于反汇编有一点需要注意的是，对于 x86 这样指令长度不固定的程序，一定要保证反汇编的起始地址正好是一条指令的开始，否则就会导致指令错位，得到错误的反汇编结果。



## Windbg命令概览

### 标准命令

​		为了便于记忆，可以根据功能将标准命令归纳为如下18个子类。

- 控制调试目标执行，包括恢复运行的g系列命令、跟踪执行的t系列命令(trace into)、单步执行的p系列命令(step over)和追踪监视的wt命令。
- 观察和修改通用寄存器的 r 命令，读写 MSR 寄存器的 rdmsr 和 wrmsr ,设置寄存器显示掩码的rm命令。
- 读写 IO 端口的 ib/iw/id 和 ob/ow/od 命令。
- 观察、编辑和搜索内存数据的 d 系列命令、e 系列命令和 s 命令。
  观察栈的k系列命令。 
- 设置和维护断点的bp (软件断点)、ba (硬件断点)和管理断点的bl (列出所有断
  点)、bc/bd/be (清除、禁止和重新启用断点)命令。
  显示和控制线程的~命令。
  显示进程的|命令。
- 评估表达式的 ? 命令和评估C++表达式的 ?? 命令。
- 用于汇编的 a 命令和用于反汇编的 u 命令。
- 显示段选择子的 dg 命令。
- 执行命 令文件的 $ 命令。
- 设置调试事件处理方式的 sx 系列命令，启用与禁止静默模式的 sq 命令，设置内核选项的 so 命令，设置符号后缀的 ss 命令。
- 显示调试器和调试目标版本的version命令，显示调试目标所在系统信息的
- 检查符号的x 命令。
- 控制和显示源程序的ls系列命令。
- 加载调试符号的 ld 命令，搜索相邻符号的 In 命令和显示模块列表的 lm 命令。
- 结束调试会话的 q 命令，包括用于远程调试的 qq 命令，结束调试会话并分离调试目标的qd命令。

​        在命令编辑框中输入一个问号(?)可以显示出主要的标准命令和每个命令的简单介绍。



### 元命令

​		元命令(Meta-Command)用来提供标准命令没有提供的常用调试功能，与标准命令一样,元命令也是内建在调试器引擎或者WinDBG程序文件中的。所有元命令都以一个点(.) 开始，所以元命令也被称为点命令(Dot Command)。
​		按照功能，可以把元命令分成如下几类。

- 显示和设置调试会话和调试器选项，比如用于符号选项的.symopt , 用于符号路径的.sympath和.symfix,用于源程序文件的.srcpath、.srcnoise 和.srcfix,用于扩展命令模块路径的.extpath,用于匹配扩展命的.extmatch,用于可执行文件的.exepath,设置反汇编选项的.asm,控制表达式评估器的.expr命令。
- 控制 调试会话或者调试目标，如重新开始调试会话的.restart,放弃用户态调试目标(进程)的.abandon,创建新进程的.create命令和附加到存在进程的attach命令，打开转储文件的.opendump,分离调试目标的.detach,用于杀掉进程的.kill命令。
- 管理扩展命令模块，包括加载模块的load命令，卸载用的.unload命令和.unloadall命令，显示已经加载模块的.chain命令等。
- 管理调试器日 志文件，如.logfile (显示信息)、.logopen (打开)、logappend (追加)和.logclose (关闭)。
- 远程调试, 如用于启动remote.exe服务的.remote命令,启动调试引擎服务器的.server命令,列出可用服务器的.servers命令，用于向远程服务器发送文件的.send _file,用于结束远程进程服务器的.endpsrv,用于结束引擎服务器的.endsrv命令。
- 控制调试器， 如让调试器睡眠一段时 间的.sleep命令，唤醒处于睡眠状态的调试器的.wake命令，启动另一个调试器来调试当前调试器的.dbgdbg命令。
- 编写命令程序,包括一系列类似C语言关键字的命令，如.if、.else、.elsif、 .foreach、.do、.while、 .continue、 .catch、 .break、 .continue、 .leave、 .printf、 .block 等，我们将在本章的第18节介绍命令程序的编写方法。
- 显示或者转 储调试目标数据，如产生转储文件的.dump命令，将原始内存数据写到文件的.writemem命令，显示调试会话时间的.time命令，显示线程时间的.ttime,命令，显示任务列表的.tlist (task list)命令，以不同格式显示数字的.formats命令。输入.help可以列出所有元命令和每个命令的简单说明。

### 扩展命令

​		扩展命令(ExtensionCommand)用于实现针对特定调试目标的调试功能。与标准命令和元命令是内建在WinDBG程序文件中不同，扩展命令是实现在动态加载的扩展模块(DLL)中的。

​		用户也可以使用以下方法手动加载扩展模块。

- 使用.load 命令加上扩展模块的名称或者完整路径来加载它。如果没有指定路径，那么WinDBG会在扩展模块搜索路径(EXTPATH) 中寻找这个文件。
- 使用.loadby 命令加上扩展模块的名称和一一个已经加载的程序模块的名称。这时WinDBG会在指定的程序模块文件所在目录中寻找和加载扩展命令模块。例如，在调试托管程序时，可以使用.loadby sos mscorwks 命令让WinDBG在mscorwks模块所在的目录中加载Sos扩展模块，这样可以确保加载正确版本的sos模块。

​        当使用“!扩展模块名扩展命令名”的方式执行扩展命令时，如果指定的扩展模块
还没有加载，那么WinDBG会自动搜索和加载这个模块。

​		使用.chain命令可以列出当前加载的所有扩展模块,使用.unload和.unloadall命令可以卸载指定的或者全部扩展模块。大多数扩展模块都支持help命令来显示这个模块的基本信息和所包含的命令，例如执行!ext.help可以显示ext模块中的所有扩展命令。



## 输入和执行命令

### 基本

​		在**<u>* BUSY *</u>**的时候输入命令不会马上执行。此外还应该记住下面的要点：

- 可以在同一行输入多条命令，用分号(;) 作为分隔符。
- 直接按回车键可以重复上一条命令。比如在使用 **<u>u</u>** 命令反汇编时，第一次输入 **<u>u</u>** 命令后，每次再按回车，WinDBG 便继续反汇编接下来的代码。
- 按上下方向键可以浏览和选择以前输入过的命令。
- 大多数命令是不区分大小写的，但是某些命令的选项是分大小写的，以显示栈回溯的 kPL 命令为例，k 不分大小写，P 和 L 是分大小写的。
- <u>输入元命令时应该以点 (.) 开始</u>，<u>输入扩展命令时应该以叹号(!)开始</u>。
- 可以使用 Ctrl+Break 来终止-一个长时间未完成的命令。如果使用 KD 或者 CDB,那么用 Ctrl+C.
- 按 Ctrl+Alt+V 热键可以启用 WinDBG 的详细输出( Verbose Output)模式，观察到更多的调试信息，再按一次恢复到本来的模式。
- 当进行内核调试时， 可以按 Ctrl+Alt+D 热键, 让 WinDBG 显示与内核调试引擎之间的数据通信，再按一次可以停止显示。
- WinDBG 的帮助文件是学习和使用 WinDBG 的好帮手，按 F1 热键或者输入.hh加上希望了解的命令，随时可以打开帮助文件并转到相关的主题。

### 表达式

​		为了支持复杂的调试命令，WinDBG 还定义了一些特殊的类似函数的运算符，它们都以 $ 字符开头。

- **<u>$iment (Address)</u>**: 返回参数 Address 所代表模块的入口地址，Address 应该为模块的基地址。例如，对于 VC 编译器产生的普通 EXE 模块,其基地址为 400000, $iment (400000)的返回值就是编译器插入的入口函数(_ _WinMainCRTStartup)地址。
- **<u>$scmp (“string1”, “string2")</u>**: 比较参数指定的两个字符串，与strcmp类似。
- **<u>$sicmp ("“string1",“string2")</u>**:比较参数指定的两个字符串, 忽略大小写，与stricmp类似。
- **<u>$spat(“string1”,“atterm")</u>**:判断参数 1 指定的字符串是否符合参数 2 指定的模式。模式字符串中可以包含?、*、#等特殊符号，WinDBG 帮助文件中String Wildcard Syntax一节包含了详细的说明。
- **<u>$vvalid (Address, Length)</u>**:判断指定区域是不是有效的内存区，有效返回1 ,否则返回 0。
- **<u>$fnsucc (FnAddress, RetVal, Flag)</u>**:根据函数的返回值评估函数是否成功。



### 伪寄存器

​		为了可以方便地引用被调试程序中的数据和寄存器，WinDBG 定义了一系列伪寄存器(Pseudo-Register)。 在命令编辑框和命令文件中都可以使用伪寄存器，解析命令的过程中，WinDBG的调试器引擎会自动将伪寄存器替换(展开)为合适的值。下表列出了当前版本的WinDBG所定义的伪寄存器。.

![伪寄存器](.\markdownimage\伪寄存器.png)

​		可以直接用上表中的名称来使用伪寄存器,但是更快速的方法是**<u>在$前加上一个@符号。这样，WinDBG就知道@后面是-一个伪寄存器，不需要搜索其他符号。</u>**



### 进程和线程限定符

​		在很多命令前可以加上进程和线程限定符，用来指定这些命令所适用的进程和线程，下表列出了两种限定符的典型用法和含义。

![进程和线程限定符](.\markdownimage\进程和线程限定符.png)

​				例如，可以使用以下命令来显示0号线程的寄存器和栈回溯，尽管当前线程是 1 号线程:
`0:001> ~0r;  ~0k;`
以上两条命令可以简写为如下形式:
`0:001> ~0e  r;  k;`
​		注意这里，如果没有 e，那么 <u>**k 命令便是显示当前线程(1号)的栈回溯**</u>。利用 ~* 可以对当前进程的所有线程执行 - 系列命令,比如以下命令对每个线程分别执行r和k命令: 

`0:001>~*er; k;`





## 建立调试会话

### 调试dump文件

WinDBG支持以下三种方式来打开一- 个转储文件。

- 运行WinDBG,接着选择File菜单中的Open Crash Dump,然后选择要打开的转储文件。
- 使用命令行方式，通过WinDBG的-z开关来指定要打开的转储文件。
- 在当前 调试会话中执行.opendump命令,这种方式需要先有一一个调试会话，适用于调试多个目标的情况。

#### dump文件格式

​		为了方便生成和读取，转储文件的格式非常简单，主要由四个部分组成。
​				第一部分是位于文件的开始处的文件头，它是一个固定格式的数据结构(MINIDUMP_HEADER)。
​				第二部分是目录表，目录表中的每个目录项是一个固定长度的名为MINIDUMP_ DIRECTORY的结构，用来描述一个数据流。
​				在目录表之后(第三部分)便是一个个的数据流。
​				第四部分是不定数量的内存块。
​		下图画出了以上三种数据的布局示意图。.

![用户态转储文件布局](.\markdownimage\用户态转储文件布局.png)



#### 利用转储文件分析问题

​		下面我们介绍使用 WinDBG 来分析转储文件的基本过程。我们仍然以user.dmp 文件为例。启动 WinDBG，然后通过文件菜单(File > Open Crash Dump)打开要分析的转储文件，即 data 目录下的 user.dmp .
​		打开文件后，WinDBG便会显示转储文件的概要信息、注释信息和异常信息，即下列清单信息：

![dump例子](.\markdownimage\dump例子.png)

​		第3行显示的便是注释(CommentStreamA)数据流的内容，其内容告诉我们这个转储文件是 Dr.Watson 程序所产生的。第5行开始显示了转储文件中所包含的异常数据流(ExceptionStream)， 这看起来与调试器收到异常的情景类似。转储文件通常是在应用程序因为未处理异常而被系统关闭前产生的，因此，分析转储文件中所记录的异常信息对了解应用程序崩溃的原因非常重要。

​		❤对于本例，

​				从异常代码那一行可以看到**<u>应用程序(进程号0xd50)的0x1128号线程内发生了访问违例异常</u>**。
​				从寄存器信息中的 EIP 值可以知道导致异常的代码位置是 0x40100d，因为应用程序的 EXE 文件通常被加载在进程中 0x400000 开始的位置，所以出现这个问题的指令可能是属于 EXE 模块的，倒数第2行中WinDBG帮我们定位到的符号位置(UEF+0x100d) 可以证实这一点。其中，UEF 是 EXE 模块名，+0x100d 表示发生异常的位置相对于 UEF 模块基地址的偏移是 0x100d。
​				 最后一行是导致异常的指令，我们前面介绍过，这是在向地址 0 写入常量1。

​		至此，我们可以判断出这个转储文件所对应的应用程序因为EXE模块中执行了空指针访问而导致了异常。

​		那么，如何进一步定位异常的发生位置呢?比如在哪个函数里?这需要符号文件的帮助，因此，我们应该将UEF程序的符号文件所在的目录(同样是data目录)设置到WinDBG的符号路径中(File>Symbol File Path...),然后执行**<u>. reload命令</u>**。

```
0:000> .reload
..........
*** WARNING:Unable to verify checksum for UEF.exe
```

​		上面的警告信息可以忽略，接下来可**<u>通过 . ecxr 命令让 WinDBG 重新显示异常信息</u>**:
0: 000> .ecxr
...
UEF ! main+0xd :

​		这次，WinDBG 便给出了更确切的异常发生位置，即距离 UEF 模块的 main 函数入口偏移 0xd 字节的位置。0xd 是个较小的偏移,于是我们可以断定异常是发生在main 函数的入口附近的。

​		那么能否定位到异常对应的源代码呢?

​		答案是可能的。**<u>要做到这一点， 需要符号文件中包含源代码行信息，通常是调试版本的符号文件才包含这个信息，以上转储文件对应的程序文件是发布版本的，它的符号文件中不包含源代码行信息，所以做不到这一点。</u>**
​		**<u>如果是调试版本的，那么设置好源文件路径后,再执行. ecxr 命令或. reload命令，WinDBG便会自动打开对应的源程序文件并加亮对应的代码行。</u>**

​		下面再介绍如何使用 WinDBG 观察转储文件中的其他信息。首先可以使用 **<u>!cpuid 命令</u>**观察系统信息(SystemInfoStream) 中的处理器信息，例如:
0:000> ! cpuid
CP F/M/S Manufacturer
6,9,5  GenuineIntel

​		可以使用**<u>~命令</u>**来显示线程信息，并通过**<u>~ <线程号> s 命令切换当前线程</u>**。
0:000> ~
0    Id: a50.1128 Suspend: -1 Teb: 7f fde000  Unfrozen

​		另外，使用 **<u>1m 命令可以显示模块信息</u>**，使用 **<u>kv 命令可以观察栈回溯信息</u>**，使用 !handle 命令可以观察句柄信息(需要转储文件中包含HandleDataStream),在此不再详细介绍。





## 理解上下文

​		Windows是个典型的多任务操作系统,在一-个系统中可以有多个登录会话(Logon Session),每个会话中可以运行多个进程，每个进程又可以包含很多个线程。在调试这样的系统时，大多数命令操作或者执行结果都是基于一定上下文的(Context)。 根据Windows操作系统的特征，

​		WinDBG 定义了如下几种上下文:会话上下文、进程上下文、寄存器上下文和局部(变量)上下文。本节将分别介绍每种上下文的含义和切换方法。

### 寄存器上下文

​		当我们在调试器中观察一个线程的寄存器(不包括MSR寄存器)时，这个线程是处于挂起状态的，所以我们看到的寄存器都是保存在内存中的寄存器值，而不是此时物理寄存器的值。当我们修改寄存器时，也是修改保存在内存中的寄存器值。

​		系统在以下几种情况下会将 CPU 的寄存器值保存到当前线程的上下文记录
(Context Record)中。

- 当系统做线程切换时，系统会将要挂起线程的寄存器取值保存起来，这个上下文常被称为线程.上下文。
- 当发生中断或者异常时，系统会将当时的寄存器取值保存起来，这个上下文常被称为异常上下文。

​        使用.thread命令可以显示或者设置寄存器上下文所针对的线程，例如以下命令显示当前的隐含线程:
`1: kd> . thread`
`Implicit thread is now 83f81950`

​		这时再使用观察寄存器和栈命令，WinDBG会提示命令结果是针对上次设置的上下文的，例如:

![寄存器上下文](.\markdownimage\寄存器上下文.png)

​		输入 .cxr 或者输入不带参数的 .thread 命令，可以将线程上下文恢复成以前的情况。
​		当调试用户态的转储文件时，可以使用 .ecxr 命令将转储文件中保存的异常上下文设置为寄存器上下文。



### 局部（变量）上下文

​		所谓局部上下文(Local Context)，就是指局部变量所基于的语境。**<u>局部变量是指定义在函数内部的变量，这些变量的含义与当前的执行位置密切相关</u>**。在调试时，调试器默认显示的是当前函数(程序指针)所对应的局部上下文。因为当前函数和局部变量都是与栈帧密切相关的，所以WinDBG调试器通常使用栈帧号来代表局部上下文。

​		使用不带任何参数的 .frame 命令可观察当前的局部上下文，例如:

`0:000> . frame
00 0012 fdb47e418724 UefWIn32 !WndProc+0xe1 [c:\...\UefWin32.cpp @ 151]`

​		这说明当前栈帧对应的函数是 WndProc ,此时使用 dv 命令可以显示这个函数的参数和局部变量:

`0:000> dv
			rt = struct  tagRECT
		  hWnd = 0x002d0500 ...`

使用 .frame 加上栈帧号可以将局部上下文切换到指定的栈帧，例如:

`0:000> .frame 5
05 0012ff30 004018b3 Ue fWIn32 ! WinMain+0xf3 [c:\...\UefWin32.cpp @ 48]`

此时可以使用 dv 命令显示 WinMain 函数的参数和局部变量:

`0:000> dv` 
`      hIns tance = 0x00400000`
`hPrevInstance = 0x00000000 ...`





## 观察栈

​		今天我们所使用的计算机系统都是基于栈架构的，栈是进行函数调用的基础。栈中记录了软件运行的丰富信息,观察和分析栈是软件调试的一-种重要手段。 第22章详细讨论过栈的布局，栈帧的建立和变量分配等内容，本节将介绍如何WinDBG调试器中观察和分析伐。

### 显示栈回溯.

​				因为函数调用指令(CALL)会将函数的返回地址记录在栈上，因此通过从栈项向下遍历每个栈帧来追溯函数调用过程，这个过程被称为栈回溯(Stack Backtrace)

​		**<u>WinDBG的k系列命令就是用来帮助我们进行栈回溯的</u>**。这一系列命令 都是以字符k开头的，它们的功能类似，显示格式有所不同。

### 观察栈变量

​			大多数局部变量是分配在栈上的。观察函数的栈帧就可以看到这个函数在栈上的局部变量。可以**<u>使用 dd 命令加上栈帧地址来观察栈帧的原始内存，但这样观察到的结果难以理解，WinDBG 的 dv 命令可以帮助我们以更友好的方式显示栈上的局部变量。</u>**
​		当位于main函数入口的断点命中时，执行 dv 命令，其结果如清单30-17所示。

![观察栈变量](.\markdownimage\观察栈变量.png)



