[TOC]

# 拷贝、赋值与销毁

## 拷贝构造函数

​			如果一个构造函数的第一个参数是自身类类型的引用，
​			且任何额外参数都有默认值，
​		则此构造函数是拷贝构造函数。

```c++
class Foo{
public:
  Foo();						//默认构造函数
  Foo(const Foo&);  //拷贝构造函数
  //...
}
```

<u>拷贝构造函数的第一个参数必须是一个引用类型</u>。

虽然我们可以定义一个非const引用的拷贝构造函数，但此参数几乎总是一个const的引用。

拷贝构造函数在几种情况下都会被隐式调用。因此，拷贝构造函数通常都不应该是explicit的(不是强匹配的)。

### 合成拷贝构造函数

​		如果我们没有定义类的拷贝构造函数，编译器就会给我们定义一个。一般来说，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中<u>依次</u>将<u>每个</u><u>非static成员</u>拷贝到正在创建的对象中。

​		每个成员的类型决定了它如何拷贝：
​				对类类型的成员，会使用其拷贝构造函数来拷贝；
​				内置类型的成员则直接拷贝。

​		虽然我们不能直接拷贝一个数组，但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝。

例：

```c++
class Sales_data {
public:
	//其他成员和构造函数的定义，如前
	//与合成的拷贝构造函数等价的拷贝构造函数的声明
	Sales_data (const Sales_data&);
private:
	std: :string bookNo;
	int units_ sold = 0;
	double revenue = 0.0;
};

//与Sales_data的合成的拷贝构造函数等价
Sales_data::Sales_data(const Sales data &orig) :
bookNo(orig.bookNo),				// 使用string的拷贝构造函数
units_sold(orig.units_sold),// 拷贝orig.units sold
revenue(orig.revenue)				// 拷贝orig. revenue
{
  //空函数体
}
```

#### 拷贝初始化

下面是拷贝初始化和直接初始化的差异：

```c++
string dots(10， '.') ;
//使用的是直接初始化

string s(dots);
//使用的是直接初始化

string s2 = dots;
//使用的是拷贝初始化

string null_ book = "9-999-99999-9";
//使用的是拷贝初始化

string nines = string(100， ' 9') ;
//使用的是拷贝初始化
```

​		当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。

​		当我们使用**拷贝初始化(copy initialization)**时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

​		拷贝初始化通常使用拷贝构造函数来完成。但是，如果一个类有一个<u>移动构造函数</u>，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。但现在，我们只需了解拷贝初始化何时发生，以及拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的就可以了。

​		拷贝初始化不仅在我们用 = 定义变量时会发生，在下列情况下也会发生：

- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
- 某些容器在 insert 或 push 成员时也会对元素进行拷贝初始化



## 拷贝赋值运算符

与类控制其对象如何初始化一样，类也可以控制其对象如何赋值：

```c++
Sales_data trans , accum;
trans = accum;//使用Sales_data的拷贝赋值运算符
```

与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

### 重载赋值运算符

​		重载运算符本质上是函数，其名字由 **operator** 关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为 **operator =** 的函数。类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。

​		重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的 this 参数。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。拷贝赋值运算符接受一个与其所在类相同类型的参数:

```c++
class Foo {		
public:
		Foo& operator= (const Foo&); //赋值运算符
		//...
};
```

​		<u>**为了与内置类型的赋值保持一致， 赋值运算符通常返回一个指向其左侧运算对象的引用**</u>。另外值得注意的是，标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。

### 合成拷贝赋值运算符

​		与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个**合成拷贝赋值运算符(synthesized copy-assignment operator)**。 

​		类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值。如果拷贝赋值运算符并非出于此目的，它会将右侧运算对象的<u>每个非static成员</u>赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

作为一个例子，下 面的代码等价于Sales_data 的合成拷贝赋值运算符:

```c++
//等价于合成拷贝赋值运算符
Sales_data&
Sales_data :: operator= (const Sales_data &rhs) {
		bookNo     = rhs.bookNo;				 //调用string::operator=
		units_sold = rhs.units_sold; 		 //使用内置的int赋值
		revenue    = rhs.revenue;			   //使用内置的double赋值
		return *this;								 		 //返回一个此对象的引用
}
```

## 析构函数

​		析构函数执行与构造函数相反的操作：
​			构造函数初始化对象的<u>非static数据成员</u>，还可能做一些其他工作；
​			析构函数释放对象使用的资源，并销毁对象的<u>非static数据成员</u>。

​		析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数:

```c++
class Foo {
public:
  	~Foo();//析构函数
  	//...
};
```

​		由于析构函数不接受参数，因此它不能被重载。**<u>对一个给定类，只会有唯一一个析构函数</u>**。



​		如同构造函数有一个初始化部分和-一个函数体，析构函数也有一个函数体和一个析构部分。
​			在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。
​			在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。


📢**注意**：<u>隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象</u>。
与普通指针不同，智能指针是类类型，所以具有析构函数。因此，与普通指针不同，智能指针成员在析构阶段会被自动销毁。



## 三五法则

​		有三个基本操作可以控制类的拷贝操作：

- 拷贝构造函数
- 拷贝赋值运算符
- 析构函数

📢**注意：****如果一个类需要自定义析构函数，几乎可以肯定也需要自定义拷贝赋值运算符和拷贝构造函数。**

例：现有一个类HasPtr中含有<u>许多指针成员</u>，而且只有析构函数没有拷贝函数。现有一个函数：

```c++
HasPtr f (HasPtr hp)		// HasPtr 是传值参数，所以将被拷贝
{
		HasPtr ret = hp;		// 拷贝给定的 HasPtr 
		//处理ret
		return ret ;				// ret 和 hp 被销毁
}
```

​		上述代码中的两次拷贝（参数拷贝和运算符拷贝），都用的合成拷贝函数，所以对于类中指针成员，都只是简单的地址拷贝！

​		当最后一步 ret 和 hp 被销毁时，会先处理 ret 的销毁，把 ret 中的指针成员指向的内存也销毁，当销毁hp时，指针指向的内存已经被销毁了，故 delete 两次！



## 使用=default

​		我们可以通过将拷贝控制成员定义为 =default 来显式地要求编译器生成合成的版本：

```c++
class Sales data {
public:
		//拷贝控制成员;使用default
		Sales_data()=default;
		Sales_data(const Sales data&)=default;
		Sales_data& operator=(const Sales_data &) ;
		~Sales_data()=default;
		//其他成员的定义，如前
};
Sales_data& Sales_data: : operator=(
  const Sales_data&)=default;
```

​		当我们在类内用 =default 修饰成员的声明时，合成的函数将隐式地声明为内联的(就像任何其他类内声明的成员函数一样)。 如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用 =default，就像对拷贝赋值运算符所做的那样。



## 阻止拷贝

​		虽然大多数类应该定义(而且通常也的确定义了)拷贝构造函数和拷贝赋值运算符,但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。

​		例如，iostream 类阻止了拷贝，以避免多个对象写入或读取相同的 IO 缓冲。为了阻止拷贝，看起来可能应该不定义拷贝控制成员。但是，这种策略是无效的:如果我们的类未定义这些操作，编译器为它生成合成的版本。

### 定义删除函数

​		在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数(deleted function)**来阻止拷贝。

​		删除的函数是这样一种函数: 我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上 **=delete** 来指出我们希望将它定义为删除的:

```c++
struct NoCopy {
			NoCopy() = default;									//使用合成的默认构造函数
			NoCopy (const NoCopy&) = delete;		//阻止拷贝
			NoCopy &operator= (const NoCopy&) = delete;//阻止赋值
  		~NoCopy() = default;								//使用合成的析构函数
			//其他成员
};
```

=delete 通知编译器(以及我们代码的读者)，我们不希望定义这些成员。

### 析构函数不能是删除的成员

​		值得注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象。而且，如果一个类有某个成员的类型删除了析构函数，我们也不能定义该类的变量或临时对象。因为如果--个成员的析构函数是删除的，则该成员无法被销毁。而如果一个成员无法被销毁，则<u>对象整体也就无法被销毁</u>了。



### 合成的拷贝控制成员可能是删除的

​		如前所述，如果我们未定义拷贝控制成员，编译器会为我们定义合成的版本。类似的，如果一个类未定义构造函数,编译器会为其合成一个默认构造函数。对某些类来说，编译器将这些合成的成员定义为删除的函数:

- 如果类的某个成员的析构函数是删除的或不可访问的(例如，是private 的), 则类的合成析构函数被定义为删除的。
- 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。
- 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个 const 的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。
- 如果类的某个成员的析构函数是删除的或不可访问的，或是类有-一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数,则该类的默认构造函数被定义为删除的。

​        本质上，这些规则的含义是：**<u>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的</u>**。

​		一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的，这看起来可能有些奇怪。其原因是，如果没有这条规则，我们可能会创建出无法销毁的对象。

​		对于具有引用成员或无法默认构造的 const 成员的类，编译器不会为其合成默认构造函数，这应该不奇怪。同样不出人意料的规则是：如果一个类有 const 成员，则它不能使用合成的拷贝赋值运算符。毕竟，此运算符试图赋值所有成员，而将一个新值赋予一个 const 对象是不可能的。

​		虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值，而不是引用本身。如果为这样的类合成拷贝赋值运算符，则赋值后，左侧运算对象仍然指向与赋值前一样的对象，而不会与右侧运算对象指向相同的对象。由于这种行为看起来并不是我们所期望的，因此对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。