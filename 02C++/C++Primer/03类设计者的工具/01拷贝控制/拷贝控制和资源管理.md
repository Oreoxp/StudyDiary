# 拷贝控制和资源管理

[TOC]

​		通常，管理类外资源的类必须定义拷贝控制成员。这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。

​		为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：<u>可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针</u>。

- 类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。
- 行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。

​		在我们使用过的标准库类中，标准库容器和 string 类的行为像一个值。 而不出意外的，shared_ptr 类提供类似指针的行为，IO 类型和 unique_ptr 不允许拷贝或赋值，因此它们的行为既不像值也不像指针。

​		为了说明这两种方式，我们会为练习中的 HasPtr 类定义拷贝控制成员。首先，我们将令类的行为像一个值;然后重新实现类，使它的行为像一个指针。

​		我们的 HasPtr 类有两个成员，一个 int 和一个 string 指针。通常，类直接拷贝内置类型(不包括指针)成员；这些成员本身就是值，因此通常应该让它们的行为像值一样。我们如何拷贝指针成员决定了像 HasPtr 这样的类是具有类值行为还是类指针行为。

## 行为像值的类

​		为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。这意味着对于 ps 指向的 string，每个 HasPtr 对象都必须有自己的拷贝。为了实现类值行为，HasPtr 需要

- 定义一个拷贝构造函数，完成 string 的拷贝，而不是拷贝指针
- 定义一个析构函数来释放 string
- 定义一个拷贝赋值运算符来释放对象当前的string， 并从右侧运算对象拷贝string

类值版本的HasPtr如下所示：

```c++
class HasPtr {
public:
		HasPtr (const std::string &S = std::string() ) :
					ps (new std::string(s)), i(0) {  }
		//对 ps 指向的 string ,每个 HasPtr 对象都有自己的拷贝
  
		HasPtr (const HasPtr &p) : 
  				ps (new std::string(*p.ps)), i(p.i) {  }
  
		HasPtr& operator= (const HasPtr &) ;
		~HasPtr() { delete ps; }
private:
		std: :string *ps;
		int	i;
];
```

​		我们的类足够简单，在类内就已定义了除赋值运算符之外的所有成员函数。第一个构造函数接受一个(可选的) string参数。这个构造函数动态分配它自己的string副本，并将指向 string 的指针保存在 ps 中。拷贝构造函数也分配它自己的 string 副本。析构函数对指针成员 ps 执行 delete , 释放构造函数中分配的内存。

### 类值拷贝赋值运算符

​	在本例中，通过先拷贝右侧运算对象，我们可以处理自赋值情况，并能保证在异常发生时代码也是安全的。在完成拷贝后，我们释放左侧运算对象的资源，并更新指针指向新分配的 string：

```c++
HasPtr& HasPtr: :operator= (const HasPtr &rhs){
		auto newp = new string(*rhs.ps); //拷贝底层string
		delete this->ps;											 //释放旧内存
  	this->ps = newp;											 //从右侧运算对象拷贝数据到本对象
		this->i = rhs.i;
		return *this; 										//返回本对象
}
```