# 智能指针

[TOC]

## shared_ptr类

一些sharedptr<u>独有</u>操作：

```c++
make_shared<T> (args);
//返回一个shared_ptr，指向一个动态分配的类型为T的对象。用args初始化此对象

shared_ptr<T> p(q);
//p是shared_ptr q的拷贝；此操作会递增q的计数器。q中的指针必须能转换成T*

p = q;
//p和q都是shared_ptr，所保存的指针必须能互相转换。此操作会递减p的引用技术，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放。

p.unique();
//若p.use_count()为1，返回true；否则返回false

p.use_count();
//返回与p共享对象的只能指针数量；
```

### make_shared函数

​		最安全的分配和使用动态内存的方法是调用一个名为**make_shared**的标准库函数。

```c++
shared_ptr<int> p3 = make_shared<int>(42);
or
auto p2 = make_shared<int>(43);
```

### shared_ptr和new结合使用

我们可以用 new 返回的指针来<u>初始化</u>智能指针：

```c++
shared_ptr<double> p1;						//shared_ptr可以指向一个double
shared_ptr<int> p2(new int(42));	//p2 指向一个值为 42 的 int
```

#### 不要混用普通指针和智能指针

#### 不要使用get初始化另一个智能指针或为智能指针赋值

​		智能指针类型定义而一个名为**get**的函数，它返回一个内置指针，指向智能指针管理的对象。此函数是为了这样一种情况而设计的：我们需要向不能使用指针的代码传递一个内置指针。<u>使用**get**返回的指针的代码不能**delete**此指针</u>。

```c++
shared_ptr<int> p(new int(42));//引用计数为1
int *q = p.get();							 //正确：但要注意q不能被释放
{//新程序块
  //未定义：两个独立的shared_ptr指向相同的内存
		shared_ptr<int>(q);
}//程序块结束，q被摧毁，它指向的内存被释放
int foo = *p;										//未定义：p指向的内存已经被释放了
```

q在程序块中被销毁后，导致q指向的内存被释放，从而p变成一个空悬指针，从而影响后面的使用！！

### 其他shared_ptr操作

​		shared_ptr还有一些操作，比如我们可以用reseet来将一个新的指针赋予一个shared_ptr：

```c++
p = new int(1024);				//错误：不能将一个指针赋予shared_ptr
p.reset(new int(1024));		//正确：p指向一个新对象
```

与赋值类似，reset会更新引用计数，如果需要的话，会释放p指向的对象。reset成员经常与unique一起使用，来控制多个shared_ptr共享的对象。在改变底层对象之前，我们检查自己是否是当前对象仅有的用户。如果不是，在改变之前要制作一份新的拷贝：

```c++
if(!p.unique())
  	p.reset(new string(*p));		//我们不是唯一的用户；分配新的拷贝
*p += newVal;										//现在我们知道自己是唯一的用户，可以改变对象的值
```

#### 带删除器的shared_ptr：

​		当shared_ptr中的类型需要在释放前做一些操作：

```c++
void tcp_destroy(tcp_class *p){
		//do someing
}

void main(){
  tcp_class c = tcp_class(/*args*/);
  shared_ptr<tcp_class> p(&c, tcp_destroy);
}//当main退出时（即使是由于异常而退出），tcp_class会被正确关闭！
```







### ⚠️shared_ptr的一些注意事项

​		智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范：

- 不使用相同的内置指针值初始化（或**reset**）多个智能指针。
- 不**delete get()**返回的指针。
- 不使用**get()**初始化或**reset**另一个智能指针。
- 如果你使用**get()**返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。
- 如果你使用智能指针管理的资源不是**new**分配的内存，记住传递给它一个删除器。















