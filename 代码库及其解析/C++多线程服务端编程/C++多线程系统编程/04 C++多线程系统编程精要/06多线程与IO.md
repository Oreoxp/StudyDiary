# 多线程与 IO

​		这可算是本章最为关键的一节。本书只讨论同步 IO , 包括阻塞与非阻塞 , 不讨论异步 IO ( AIO)。

​		在进行多线程网络编程的时候，几个自然的问题是 : 如何处理 IO ? 能否多个线程同时读写同一个 socket 文件描述符 ? 我们知道用多线程同时处理多个 socket 通常可以提高效率，那么用多线程处理同**一个** socket 也可以提高效率吗?

​		首先，操作文件描述符的系统调用本身是线程安全的，我们不用担心多个线程同时操作文件描述符会造成进程崩溃或内核崩溃。

​		但是，多个线程同时操作同一个 socket 文件描述符确实很麻烦，是得不偿失的。需要考虑的情况如下:

- 如果一个线程正在阻塞地 read(2) 某个 socket ,  而另一个线程 close(2) 了此 socket 。
- 如果一个线程正在阻塞地 accept(2) 某个 listening socket， 而另一个线程
   close(2) 了此 socket 。
- 更糟糕的是，一个线程正准备 read(2) 某个 socket , 而另一个线程 close(2) 了此 socket ; 第三个线程又恰好 open(2) 了另一个文件描述符，其 fd 号码正好与前面的 socket 相同。这样程序的逻辑就混乱了(下一章讲 )。

​        这都反映了程序逻辑设计上有问题。

​		现在假设不考虑关闭文件描述符，只考虑读和写，情况也不见得多好。因为 socket 读写的特点是**不保证完整性**，读 100 字节有可能只返回 20 字节，写操作也是一样的。

- 如果两个线程同时 read 同一个 TCP socket , 两个线程几乎同时各自收到一部分数据，如何把数据拼成完整的消息 ? 如何知道哪部分数据先到达 ?
- 如果两个线程同时 write 同一个 TCP socket ,  每个线程都只发出去半条消息，那接收方收到数据如何处理 ?
- 如果给每个 TCP.  socket 配一把锁， 让同时只能有一个线程读或写此socket , 似乎可以“解决”问题，但这样还不如直接始终让同-个线程来操作此 socket 来得简单。
- 对于非阻塞 IO , 情况是一样的，而且收发消息的完整性与原子性几乎不可能用锁来保证，因为这样会阻塞其他 IO 线程。

​        为了简单起见，我认为多线程程序应该遵循的原则是 : 每个文件描述符只由一一个线程操作，从而轻松解决消息收发的顺序性问题，也避免了关闭文件描述符的各种 race condition。一个线程可以操作多个文件描述符，但一个线程不能操作别的线程拥有的文件描述符。这一点不难做到，muduo 网络库已经把这些细节封装了。

















