# 高效的多线程日志

​		在服务端编程中，日志是必不可少的，在生产环境中应该做到 “ Log Everything All The Time " 。对于关键进程，日志通常要记录

1. 收到的每条内部消息的 id ( 还可以包括关键字段、长度、hash 等);
2. 收到的每条外部消息的全文;
3. 发出的每条消息的全文，每条消息都有全局唯一-的 id 6;
4. 关键内部状态的变更，等等。

​        一个日志库大体可分为前端 ( frontend ) 和后端 ( backend )两部分。前端是供应用程序使用的接口 ( API ) , 并生成日志消息 ( log message ) ; 后端则负责把日志消息写到目的地 ( destination )。这两部分的接口有可能简单到只有一个回调函数:

`void output(const char* message , int len);`

​		其中的 message 字符串是一条完整的日志消息，包含日志级别、时间戳、源文件位置、线程 id 等基本字段，以及程序输出的具体消息内容。

​		在多线程程序中，前端和后端都与单线程程序无甚区别，无非是每个线程有自己的前端，整个程序共用一个后端。但难点在于将日志数据从多个前端高效地传输到后端。这是一个典型的多生产者 - 单消费者问题，对生产者 ( 前端 )而 言，要尽量做到低延迟、低 CPU 开销、无阻塞 ; 对消费者 ( 后端 ) 而言，要做到足够大的吞吐量,  并占用较少资源。

​		对 C++ 程序而言，最好整个程序 ( 包括主程序和程序库 ) 都使用相同的日志库,程序有一个整体的日志输出，而不要各个组件有各自的日志输出。从这个意义上讲,日志库是个 singleton。

​		C++ 日志库的前端大体上有两种 API 风格:

- C/Java 的 printf ( fmt, ... ) 风格 , 例如
  log_info("Received %d bytes from %s",  len,  getClientName().c_str());
- C++ 的 stream << 风格，例如
  LOG_ INFO << "Received " << len «< " bytes from " << getClientName ();











