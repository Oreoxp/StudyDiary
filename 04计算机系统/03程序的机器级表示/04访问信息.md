## 访问信息

​		一个 x86-64 的中央处理单元（CPU）包含一组16 个存储 64 位值的**通用目的寄存器**。 这些寄存器用来存储整数数据和指针。图3-2显示了这 16 个寄存器。它们的名字都以 **％r**  开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。最 初的8086中有8个16位的寄存器，即图3-2中的 **％ax** 到 **%bp**。每个寄存器都有特殊的用途，它们的名字就反映了这些不同的用途。扩展到 IA32 架构时，这些寄存器也扩展成 32 位寄存器，标号从 **％eax** 到 **%ebp** 。扩展到 x86-64 后，原来的 8 个寄存器扩展成 64 位 ，标号从 **％rax**到 **％rbp** 。除此之外，还增加了 8 个新的寄存器，它们的标号是按照新的命名规 则制定的：从 **%r8** 到 **％r15** 。

![04整数寄存器](.\markdownimage\04整数寄存器.png)

​		如图3-2中嵌套的方框标明的，指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16 位操作可以访问最低的 2 个字节，32 位操作可以访问最低的 4 个字节，而 64位操作可以访问整个寄存器。

​		在后面的章节中，我们会展现很多指令，复制和生成1字节、2字节、4字节和8字 节值。当这些指令以寄存器作为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则**：生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置为0。后面送条规则是作为从IA32到 X86-64的扩展的一部分而采用的。**

​		就像图3-2右边的解释说明的那样，在常见的程序里不同的寄存器扮演不同的角色。 其中最特别的是栈指针**%rsp**，用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。另外 15 个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。更重要的是，有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。我们会在描述过程的实现时（特别是在3.7节中），讲述这些惯例。

#### 操作数指示符

​		大多数指令有一个或多个**操作数（operand）**,指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64 支持多种操作数格式（参见图3-3)。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此， 各种不同的操作数的可能性被分为三种类型。

- 第一种类型是**立即数（immediate）**,用来<u>表示常数值</u>。在 ATT 格式的汇编代码中，立即数的书写方式是 ‘ $ ’ 后面跟一个用标准 C 表示法表示的整数，比如，$-577 或 $0x1F 。不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。

- 第二种类型是**寄存器（register）**,它<u>表示某个寄存器的内容</u>，16 个寄存器的低位 1 字节、2 字节、4 字节或 8 字节中的一个作为操作数， 这些字节数分别对应于 8 位、16 位、32 位或 64 位。在图3-3中，我们用符号 r(a)来表示任意寄存器 a ,用引用 R[r(a)] 来表示它的值，这是将寄存器集合看成一个数组 R ,用寄存器标识符作为索引。

- 第三类操作数是**内存引用**，它会<u>根据计算出来的地址（通常称为有效地址）访问某个内存位置</u>。因为将内存看成一个很大的字节数组，我们用符号 M(b)[Addr] 表示对存储在内存中从地址 Addr 开始的 b 个字节值的引用。为了简便，我们通常省去下标 b。


​		如图3-3所示，有多种不同的**寻址模式**，允许不同形式的内存引用。表中底部用语法![04公式1](.\markdownimage\04公式1.png)表示的是最常用的形式。这样的引用有四个组成部分：一个立即数偏移  Imm，一个基址寄存器 r(b)，一个变址寄存器 r(i) 和一个比例因子 s ,这里 s 必须是 1、2、4 或者 8。基址和变址寄存器都必须是64位寄存器。有效地址被计算为![04公式2](.\markdownimage\04公式2.png)。引用数组元素时，会用到这种通用形式。其他形式都是这种通用形式的特殊情况，只是省略了某些部分。正如我们将看到的，当引用数组和结构元素时，比较复杂的寻址模式是很有用的。

![04操作数格式](.\markdownimage\04操作数格式.png)

**例：**

![04练习1](.\markdownimage\04练习1.png)

|     操作数     |  值   |    注释    |
| :------------: | :---: | :--------: |
|      %rax      | 0x100 |   寄存器   |
|     0x104      | 0xAB  |  绝对地址  |
|     $0x108     | 0x108 |   立即数   |
|     (%rax)     | 0xFF  | 地址 0x100 |
|    4(%rax)     | 0xAB  | 地址 0x104 |
|  9(%rax,%rdx)  | 0x11  | 地址 0x10c |
| 260($rcx,%rdx) | 0x13  | 地址 0x108 |
| 0XFC(,%rcx,4)  | 0xFF  | 地址 0x100 |
| (%rax,%rdx,4)  | 0x107 | 地址 0x10c |

### 数据传送指令

​		<u>最频繁使用的指令是将数据从一个位置复制到另一个位置的指令</u>。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能。我们会介绍多种不同的数据传送指令，它们或者源和目的类型不同，或者执行的转换不同，或者具有的一些副作用不同。在我们的讲述中，把许多不同的指令划分成指令类， 每一类中的指令执行相同的操作，只不过操作数大小不同。

​		图3-4列出的是最简单形式的数据传送指令——MOV 类。这些指令把数据从源位置复制到目的位置，不做任何变化。MOV类由四条指令组成：movb、 movw、 movl 和 movq。这些指令都执行同样的操作；主要区别在于它们操作的<u>数据大小不同</u>：分别是 1、 2、4和8字节。

![04简单的数据传送指令](.\markdownimage\04简单的数据传送指令.png)

​		源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。x86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令——第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。参考 图3-2,这些指令的寄存器操作数可以是 16 个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符（‘b’，‘w’，‘1’或‘q’）<u>指定的大小匹配</u>。大多数情况中，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是 movl 指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。造成这个例外的 原因是 x86-64 采用的惯例，即任何为寄存器生成 32 位值的指令都会把该寄存器的高位部分置成 0 。

​		下面的 MOV 指令示例给出了源和目的类型的五种可能的组合。记住，**第一个是源操作数，第二个是目的操作数**：

```Assembly 
1	movl	$0x4050,%eax		Immediate--Register, 4 bytes
2	movw	%bp,%.sp			Register--Register,  2 bytes 
3	movb	(%rdi,%rcx),%al		Memory--Register,    1 byte 
4	movb	$-17,(%rsp)			Immediate--Memory,   1 byte 
5	movq	%rax,-12(%rbp)		RegisterMemory,      8 bytes
```

​		图3-4中记录的最后一条指令是处理 64 位立即数数据的。常规的 movq 指令只能以表示为 32 位补码数字的立即数作为源操作数，然后把这个值符号扩展得到 64 位的值，放到目的位置。movabsq 指令能够以任意 64 位立即数值作为源操作数，并且只能以寄存器作为目的。

​		图 3-5 和图 3-6 记录的是两类数据移动指令，在将较小的源值复制到较大的目的时使用。所有这些指令都把数据从源（在寄存器或内存中）复制到目的寄存器。MOVZ 类中的指令把目的中剩余的字节填充为 0 ,而 MOVS 类中的指令通过符号扩展来填充，把源操作的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符：第一个字符指定源的大小，而第二个指明目的的大小。正如看到的那样，这两个类中每个都有三条指令，包括了所有的源大小为 1 个和 2 个字节、目的大小为 2 个和 4 个的情况，当然只考虑目的大于源的情况。

![04符号扩展数据传送指令](.\markdownimage\04符号扩展数据传送指令.png)

```c
/*旁注 理解数据传送如何改变目的寄存器*/

    正如我们描述的那样，关于数据传送指令是否以及如何修改目的寄存器的高位字节 有两种不同的方法。下面这段代码序列会说明其差别：
1	movabsq $0x0011223344556677, %rax			%rax =	0011223344556677
2	movb	$-1,	%al	                   		%rax =	00112233445566FF
3	movw	$-l,	%ax							%rax =	001122334455FFFF
4	movl	$-l,	%eax						%rax =	00000000FFFFFFFF
5	movq	$-1,	%rax						%rax =	FFFFFFFFFFFFFFFF
        
	在接下来的讨论中，我们使用十六进制表示。在这个例子中，第 1 行的指令把寄存器 %rax 初始化为位模式0011223344556677。剩下的指令的源操作数值是立即数值 -1 。回想 -1 的十六进制表示形如FF…F，这里 F 的数量是表述中字节数量的两倍。因此 movb 指令 （第2行）把 ％rax 的低位字节设置为FF，而mow指令（第3行)把低2位字节设置为FFFF， 剩下的字节保持不变。movl 指令（第4行）将低4个字节设置为 FFFFFFFF,同时把高位 4 字节设置为00000000。最后 movq 指令（第5行) 把整个寄存器设置为 FFFFFFFFFFFFFFFF。
```

​		注意图3-5中并没有一条明确的指令把 4 字节源值零扩展到 8 字节目的。这样的指令逻辑上应该被命名为movzlq ，但是并没有这样的指令。不过，这样的数据传送可以用以寄存器为目的的 movl 指令来实现。这一技术利用的属性是，生成 4 字节值并以寄存器作为目的的指令会把髙4字节置为0。对于64位的目标，所有三种源类型都有对应的符号扩 展传送，而只有两种较小的源类型有零扩展传送。

​		图3-6还给出 cltq 指令。这条指令没有操作数：它总是以寄存器 %eax 作为源,%rax 作为符号扩展结果的目的。它的效果与指令 movslq %eax , %rax 完全一致，不过编码更紧凑。

**练习题3.2** 对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。（例 如，mov可以被重写成movb、movw、movl或者movq。)

mov____	%eax, (%rsp)											  
mov____	(%rax), %dx
mov____	$0xFF, %bl                                                  movb
mov____	(%rsp,%rdx,4), %dl
mov____	(7〇rdx), B/0rax
mov____	%dx, (%rax)



```c
/*旁注 字节传送指令比较*/
下面这个示例说明了不同的数据传送指令如何改变或者不改变目的的高位字节。仔细观 察可以发现，三个字节传送指令movb、movsbq和movzbq之间有细微的差别。示例如下：
movabsq $0x0011223344556677, movb $0xAA, %dl movb %dl,%al movsbq %dl,%rax movzbq %dl，％rax
%rax %rax = 0011223344556677 %dl = AA
%rax = 00112233445566AA %rax = FFFFFFFFFFFFFFAA Xrax = OOOOOOOOOOOOOOAA
在下面的讨论中，所有的值都使用十六进制表示。代码的头2行将寄存器％rax*%dl 分别初始化为0011223344556677和AA。剩下的指令都是将％rdx的低位字节复制到％rax 的低位字节。movb指令（第3行）不改变其他字节。根据源字节的最高位，movsbq指令（第 4行）将其他7个字节设为全1或全0。由于十六进制A表示二进制值1010，符号扩展会把 高位字节都设置为FF。movzbq指令（第5行）总是将其他7个字节全都设置为0。
```

