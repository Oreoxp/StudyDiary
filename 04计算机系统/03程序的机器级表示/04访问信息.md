## 访问信息

​		一个 x86-64 的中央处理单元（CPU）包含一组16 个存储 64 位值的**通用目的寄存器**。 这些寄存器用来存储整数数据和指针。图3-2显示了这 16 个寄存器。它们的名字都以 **％r**  开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。最 初的8086中有8个16位的寄存器，即图3-2中的 **％ax** 到 **%bp**。每个寄存器都有特殊的用途，它们的名字就反映了这些不同的用途。扩展到 IA32 架构时，这些寄存器也扩展成 32 位寄存器，标号从 **％eax** 到 **%ebp** 。扩展到 x86-64 后，原来的 8 个寄存器扩展成 64 位 ，标号从 **％rax**到 **％rbp** 。除此之外，还增加了 8 个新的寄存器，它们的标号是按照新的命名规 则制定的：从 **%r8** 到 **％r15** 。

![04整数寄存器](.\markdownimage\04整数寄存器.png)

​		如图3-2中嵌套的方框标明的，指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16 位操作可以访问最低的 2 个字节，32 位操作可以访问最低的 4 个字节，而 64位操作可以访问整个寄存器。

​		在后面的章节中，我们会展现很多指令，复制和生成1字节、2字节、4字节和8字 节值。当这些指令以寄存器作为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则**：生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置为0。后面送条规则是作为从IA32到 X86-64的扩展的一部分而采用的。**

​		就像图3-2右边的解释说明的那样，在常见的程序里不同的寄存器扮演不同的角色。 其中最特别的是栈指针**%rsp**，用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。另外 15 个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。更重要的是，有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。我们会在描述过程的实现时（特别是在3.7节中），讲述这些惯例。

#### 操作数指示符

​		大多数指令有一个或多个**操作数（operand）**,指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64 支持多种操作数格式（参见图3-3)。源数据值可以 以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此， 各种不同的操作数的可能性被分为三种类型。第一种类型是立即数（immediate),用来表 示常数值。在ATT格式的汇编代码中，立即数的书写方式是‘$’后面跟一个用标准C表 示法表示的整数，比如，$-577或$0xlF。不同的指令允许的立即数值范围不同，汇编器 会自动选择最紧凑的方式进行数值编码。第二种类型是寄存器（register),它表示某个寄 存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数， 这些字节数分别对应于8位、16位、32位或64位。在图3-3中，我们用符号1„来表示任 意寄存器〜用引用R[rJ来表示它的值，这是将寄存器集合看成一个数组R,用寄存器标 识符作为索引。

​		第三类操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内 存位置。因为将内存看成一个很大的字节数组，我们用符号表示对存储在内存 中从地址开始的6个字节值的引用。为了简便，我们通常省去下标6。

​		如图3-3所示，有多种不同的寻址模式，允许不同形式的内存引用。表中底部用语法 r,+，s)表示的是最常用的形式。这样的引用有四个组成部分：一个立即数偏移 fo™，一个基址寄存器3：4，一个变址寄存器r,.和一个比例因子s,这里s必须是1、2、4或者 8。基址和变址寄存器都必须是64位寄存器。有效地址被计算为^«m+R[r>] + R[r,].s。引 用数组元素时，会用到这种通用形式。其他形式都是这种通用形式的特殊情况，只是省略 了某些部分。正如我们将看到的，当引用数组和结构元素时，比较复杂的寻址模式是很有用的。