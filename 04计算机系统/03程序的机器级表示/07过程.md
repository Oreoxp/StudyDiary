## 过程

​		过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。不同编程语言中，过程的形式多样：**函数(function)**、**方法(method)**、**子例程(subroutine)**、**处理函数(handler)**等等，但是它们有一些共有的特性。

​		要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程 P 调用过程 Q ，Q 执行后返回到 P 。这些动作包括下面一个或多个机制：

- **传递控制**。在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为 P 中调用 Q 后面那条指令的地址。
- **传递数据**。P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值。
- **分配和释放内存**。在开始时，Q 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。

​		x86-64 的过程实现包括一组特殊的指令和一些对机器资源（例如寄存器和程序内存)使用的约定规则。人们花了大量的力气来尽量减少过程调用的开销。所以，它遵循了被认为是最低要求策略的方法，只实现上述机制中每个过程所必需的那些。接下来，我们一步步地构建起不同的机制，先描述控制，再描述数据传递，最后是内存管理。



### 运行时栈

​		C 语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的**后进先出**的内存管理原则。在过程 P 调用过程 Q 的例子中，可以看到当 Q 在执行时，P 以及所有在向上追溯到 P 的调用链中的过程，都是暂时被挂起的。当 Q 运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。 另一方面，当 Q 返回时，任何它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。 当 P 调用 Q 时，控制和数据信息添加到栈尾。当 P 返回时，这些信息会释放掉。

​		如3. 4. 4节中讲过的，x86-64 的栈向低地址方向增长，而栈指针 ％rsp 指向栈顶元素。可以用 pushq 和popq 指令将数据存入栈中或是从栈中取出。将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间。类似地，可以通过增加栈指针来释放空间。

​		当 x86-64 过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的**栈帧（stack fram)**。图3-25给出了运行时栈的通用结构，包括把它划分为栈帧。当前正在执行的过程的帧总是在栈 顶。当过程 P 调用过程 Q 时，会把返回地址压人栈中，指明当 Q 返回时，要从 P 程序的哪个位置继续执行。我们把这个返回地址当做 P 的桟帧的一部分，因为它存放的是与 P 相关的状态。Q 的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。大多数过程的栈帧都是定长的，在过程的开始就分配好了。但是有些过程需要变长的帧，这个问题会在3. 10.5 节中讨论。通过寄存器，过程 P 可以传递最多 6 个整数值（也就是指针和整数），但是如果 Q 需要更多的参数，P 可以在调用 Q 之前在自己的栈帧里存储好这些参数。

![07通用的栈帧结构](.\markdownimage\07通用的栈帧结构.png)

​		为了提高空间和时间效率，x86-64 过程只分配自己所需要的栈帧部分。例如，许多过程有 6 个或者更少的参数，那么所有的参数都可以通过寄存器传递。因此，图3-25 中画出的某些栈帧部分可以省略。实际上，许多函数甚至根本不需要栈帧。当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数（有时称之为叶子过程，此时把过程调用看做树结构）时，就可以这样处理。例如，到目前为止我们仔细审视过的所有函数都不需要栈帧。



### 转移控制

​		将控制从函数 P 转移到函数 Q 只需要简单地把程序计数器(PC)设置为 Q 的代码的起始位置。不过，当稍后从Q 返回的时候，处理器必须记录好它需要继续 P 的执行的代码位置。在  x86-64 机器中，这个信息是用指令 call Q调用过程 Q 来记录的。该指令会把地址 A 压入栈中，并将 PC 设置为 Q 的起始地址。压入的地址 A 被称为返回地址，是紧跟在 call 指令后面的那条指令的地址。对应的指令 ret 会从栈中弹出地址 A ，并把 PC 设置为 A 。

​		下表给出的是 call 和 ret s指令的一般形式：

![07公式1](.\markdownimage\07公式1.png)

(这些指令在程序 OBJDUMP 产生的反汇编输出中被称为 callq 和 retq 。添加的后缀只是为了强调这些是 x86-64 版本的调用和返回，而不是 IA32 的。在X86-64汇编代码中， 这两种版本可以互换。）

​		call指令有一个目标，即指明被调用过程起始的指令地址。同跳转一样，调用可以是直接的，也可以是间接的。在汇编代码中，直接调用的目标是一个标号，而间接调用的目标是 * 后面跟一个操作数指示符，使用的是图3-3中描述的格式之一。

​		图3-26说明了 3. 2_ 2节中介绍的 multstore 和 main 函数的 call 和 ret 指令的执行情况。下面是这两个函数的反汇编代码的节选：

```disassembler
Beginning of function multstore
1	0000000000400540 <multstore>:
2	400540: 53							push %rbx
3	400541: 48 89 d3					mov %rdx,%rbx
...
Return from function multstore 
4	40054d:	c3							retq
...
Call to multstore from main
5	400563:	e8 d8 ff	ff	ff			callq	400540 <multstore>
6	400568:	48 8b 54	24	08			mov	0x8(%rsp),%rdx
```

​		在这段代码中我们可以看到，在 main 函数中，地址为 0x400563 的 call 指令调用函数 multstore 。此时的状态如图3-26a所示，指明了栈指针 ％rsp 和程序计数器 ％rip 的值。 call 的效果是将返回地址 0x400568 压入栈中，并跳到函数 multstore 的第一条指令，地址为 0x0400540 (图3-26b)。函数 multstore 继续执行，直到遇到地址 0x40054d 处的 ret 指令。这条指令从栈中弹出值 0x400568 ,然后跳转到这个地址，就在 call 指令之 后，继续main 函数的执行。

![07call和ret函数的说明](.\markdownimage\07call和ret函数的说明.png)



​		再来看一个更详细说明在过程间传递控制的例子，图3-27a给出了两个函数 top 和 leaf 的反汇编代码，以及main 函数中调用 top 处的代码。每条指令都以标号标出：L1〜L2 (leaf中），T1〜T4(main中）和M1〜M2(main中）。该图的b部分给出了这段代码执

![07包含过程调用和返回的程序的执行细节](.\markdownimage\07包含过程调用和返回的程序的执行细节.png)

![07示例代码的执行过程](.\markdownimage\07示例代码的执行过程.png)

行的详细过程，main 调用 top (100)，然后 top 调用 leaf (95) 。函数 leaf 向 top 返回 97 ,然后 top 向 main 返回194 。前面三列描述了被执行的指令，包括指令标号、地址和指令类型。后面四列给出了在该指令执行前程序的状态，包括寄存器 ％rdi、％rax 和 ％rsp 的内容，以及位于栈顶的值。仔细研究这张表的内容，它们说明了运行时栈在管理支持过程调用和返回所需的存储空间中的重要作用。

​		leaf 的指令 L1 将 ％rax 设置为 97 ,也就是要返回的值。然后指令 L2 返回，它从栈中弹出 0x400054e 。通过将 PC 设置为这个弹出的值，控制转移回 top 的 T3 指令。程序成功完成对 leaf 的调用，返回到 top 。

​		指令 T3 将 %rax 设置为 194 ,也就是要从 top 返回的值。然后指令 T4 返回，它从栈中弹出 0x4000560 ,因此将 PC 设置为 main 的 M2 指令。程序成功完成对 top 的调用，返回到 main 。可以看到，此时栈指针也恢复成了 0x7fffffffe820 ，即调用 top 之前的值。

​		可以看到，这种把返回地址压入栈的简单的机制能够让函数在稍后返回到程序中正确的点。C 语言（以及大多数程序语言）标准的调用/返回机制刚好与栈提供的后进先出的内存管理方法吻合。



### 数据传送

​		当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。x86-64 中， 大部分过程间的数据传送是通过寄存器实现的。例如，我们已经看到无数的函数示例，参 数在寄存器 ％rdi 、 ％rsi 和其他寄存器中传递。当过程 P 调用过程Q 时，P 的代码必须首先把参数复制到适当的寄存器中。类似地，当 Q 返回到 P 时，P 的代码可以访问寄存器 %rax 中的返回值。在本节中，我们更详细地探讨这些规则。

​		x86-64 中，可以通过寄存器最多传递6个整型（例如整数和指针）参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，如图3-28所示。 会根据参数在参数列表中的顺序为它们分配寄存器。可以通过64位寄存器适当的部分访问小于64位的参数。例如，如果第一个参数是32位的，那么可以用 ％edi 来访问它。

![07传递函数参数的寄存器](.\markdownimage\07传递函数参数的寄存器.png)

​		如果一个函数有大于 6 个整型参数，超出 6 个的部分就要通过栈来传递。假设过程 P 调用过程 Q ,有 n 个整型参数，且 n > 6 。那么P的代码分配的栈帧必须要能容纳 7 到 n 号参数的存储空间，如图3-25所示。要把参数1〜6 复制到对应的寄存器，把参数 7〜n 放到栈上，而参数 7 位于栈顶，通过栈传递参数时，所有的数据大小都向 8 的倍数对齐。参数到位以后， 程序就可以执行 call 指令将控制转移到过程 Q了 ， 过程 Q 可以通过寄存器访间参数，有必要的话也可以通过栈访问，相应地。如果 Q 也调用了某个有超过 6 个参数的函数，它也需要在自己的栈中为超出 6 个部分的参数分配空间。如图3-25中标号为“参数构造区”的区域所示。

​		作为参数传递的示例， 考虑图3-29a所示的 C 函数 proe ， 这个函数有 8 个参数， 包括学节数不同的整数(8，4.2和1)和不同类型的指针，每个都是 8 字节的。

![07有多个不同类型参数的函数示例](.\markdownimage\07有多个不同类型参数的函数示例.png)

​		图3-29b中给出 proc 生成的汇编代码， 前面 6 个参数通过寄存器传递， 后面 2 个通过栈传道，就像图3-30中画出来的那样，可以看到，作为过程调用的一部分，返回地址被压入栈中，因面这两个参数位于相对于栈指针距离为 8 和 16 的位置，在这段代码中，我们可以看到根据操作数的大小， 使用了 ADD 指令的不同版本：a 1(long) 使用 addq ，a2(int) 使用 addl ， a3(short) 使用 addw .而 a4(char) 使用 addb .请注意第6行的 movl 指令从内存读入 4 字节， 后面的 addb 指令只使用其中的低位一字节。

![07函数proc的栈帧结构](.\markdownimage\07函数proc的栈帧结构.png)