## 控制

​		到目前为止，我们只考虑了直线代码的行为，也就是指令一条接着一条顺序地执行。 c语言中的某些结构，比如条件语句、循环语句和分支语句，要求有条件的执行，根据数据测试的结果来决定操作执行的顺序。机器代码提供两种基本的低级机制来实现有条件的行为：<u>测试数据值，然后根据测试的结果来改变控制流或者数据流。</u>

​		与数据相关的控制流是实现有条件行为的更一般和更常见的方法，所以我们先来介绍它。通常，C 语言中的语句和机器代码中的指令都是按照它们在程序中出现的次序，顺序执行的。用 jump 指令可以改变一组机器代码指令的执行顺序，jump 指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试的结果。编译器必须产生构建在这种低级机制基础之上的指令序列，来实现 C 语言的控制结构。

​		本文会先涉及实现条件操作的两种方式，然后描述表达循环和 switch 语句的方法。

### 条件码

​		除了整数寄存器，CPU还维护着一组单个位的**条件码（condition code)**寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用的条件码有：
​		**CF: 进位标志**。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
​		**ZF: 零标志**。最近的操作得出的结果为0。
​		**SF: 符号标志**。最近的操作得到的结果为负数。
​		**OF: 溢出标志**。最近的操作导致一个补码溢出一正溢出或负溢出。

​		比如说，假设我们用一条 ADD 指令完成等价于 C 表达式 t = a+b 的功能，这里变量 b 和 t 都是整型的。然后，根据下面的 C 表达式来设置条件码：
​		CF		(unsigned) t < (unsigned) a				 无符号溢出
​		ZF		(t ==0)										   		  零
​		SF		(t < 0)										  		    负数
​		OF		(a < 0 == b < 0) && (t < 0 ! = a < 0)	 有符号溢出

​		leaq 指令不改变任何条件码，因为它是用来进行地址计算的。除此之外，图3-10中列出的所有指令都会设置条件码。对于逻辑操作，例如 XOR，进位标志和溢出标志会设置成0。对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为 0 。 INC 和 DEC 指令会设置溢出和零标志，但是不会改变进位标志，至于原因，我们就不在这里深入探讨了。

​		除了图3-10中的指令会设置条件码，还有两类指令（有8、16、32和64位形式），它们只设置条件码而不改变任何其他寄存器；如图3-13所示。CMP 指令根据两个操作数之差来设置条件码。除了只设置条件码而不更新目的寄存器之外，CMP 指令与 SUB 指令的行为是—样的。在 ATT 格式中，列出操作数的顺序是相反的，这使代码有点难读。如果两个操作数相等，这些指令会将零标志设置为 1，而其他的标志可以用来确定两个操作数之间的大小关系。TEST 指令的行为与 and 指令一样，除了它们只设置条件码而不改变目的寄存器的值。典型的用法是，两个操作数是一样的（例如，testq   %rax,%rax 用来检查 ％rax 是负数、 零，还是正数），或其中的一个操作数是一个掩码，用来指示哪些位应该被测试。

![06比较和测试指令](.\markdownimage\06比较和测试指令.png)

### 访问条件码

​		条件码通常不会直接读取，常用的使用方法有三种：

- 可以根据条件码的某种组合， 将一个字节设置为 0 或者 1 ，
- 可以条件跳转到程序的某个其他的部分，
- 可以有条件地传送数据。

​        对于第一种情况，图3-14中描述的指令根据条件码的某种组合，将一个字节设置为 0 或者 1 。我们将这一整类指令称为SET指令；它们之间的区别就在于它们考虑的条件码的组合是什么，送些指令名字的不同后缀指明了它们所考虑的条件码的组合。这些指令的后缀表示不同的条件而不是操作数大小，了解这一点很重要。例如，<u>指令setl 和 setb 表示“小于时设置（set less)”和“低于时设置（set below)”，而不是“设置长字（set long word)” 和“设置字节（set byte)”。</u>

​		一条SET指令的目的操作数是低位单字节寄存器元素（图3-2)之一，或是一个字节的内存位置，指令会将这个字节设置成 0 或者 1 。为了得到一个 32 位或 64 位结果，我们必须对高位清零。一个计算C语言表达式 a < b 的典型指令序列如下所示，这里 a 和 b 都是 long 类型：

![06SET指令](.\markdownimage\06SET指令.png)

