## 浮点代码

​		处理器的**浮点体系结构**包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括：

- 如何存储和访问浮点数值。通常是通过某种寄存器方式来完成。
- 对浮点数据操作的指令。
- 向函数传递浮点数参数和从函数返回浮点数结果的规则。
- 函数调用过程中保存寄存器的规则——例如，一些寄存器被指定为调用者保存，而其他的被指定为被调用者保存。

​        简要回顾历史会对理解 x86-64 的浮点体系结构有所帮助。1997年出现了 Pentium / MMX，Intel 和 AMD 都引入了持续数代的**媒体（media)**指令，支持图形和图像处理。这些指令本意是允许多个操作以并行模式执行，称为单指令**多数据**或 **SIMD**(读作sim-dee)。 在这种模式中，对多个不同的数据并行执行同一个操作。近年来，这些扩展有了长足的发 展。名字经过了 一系列大的修改，从 MMX 到 SSE (Streaming SIMD Extension，流式 SIMD扩展），以及最新的 AVX( Advanced Vector Extension，高级向量扩展）。每一代中， 都有一些不同的版本。每个扩展都是管理寄存器组中的数据，这些寄存器组在 MMX 中称为 “ MM ” 寄存器，SSE 中称为 “ XMM ” 寄存器，而在 AVX 中称为 “YMM” 寄存器； MM 寄存器是 64 位的， XMM 是 128 位的，而 YMM 是 256 位的。所以，每个YMM 寄存器可以存放 8 个 32 位值，或 4 个 64 位值，这些值可以是整数，也可以是浮点数。

​		2000 年 Peruium 4 中引入了 SSE2 ,媒体指令开始包括那些对标量浮点数据进行操作的指令，使用 XMM 或YMM 寄存器的低 32 位或 64 位中的单个值。这个标量模式提供了一组寄存器和指令，它们更类似于其他处理器支持浮点数的方式。所有能够执行 x86-64 代码的处理器都支持 SSE2 或更高的版本，因此 X86-64 浮点数是基于 SSE 或 AVX 的，包括传递过程参数和返回值的规则[77]。

​	我们的讲述基于 AVX2 ，即 AVX 的第二个版本，它是在 2013 年 Core i7 Haswell 处理器中引入的。当给定命令行参数 -mavx2 时，GCC 会生成 AVX2 代码。基于不同版本的 SSE 以及第一个版本的 AVX 的代码从概念上来说是类似的，不过指令名和格式有所不同。 我们只介绍用 GCC 编译浮点程序时会出现的那些指令。其中大部分是标量 AVX 指令，我们也会说明对整个数据向量进行操作的指令出现的情况。后文中的网络旁注 OPT: SIMD 更全面地说明了如何利用 SSE 和 AVX 的 SIMD 功能读者可能希望参考 AMD 和 Intel 对每条指令的说明文档[4, 51]。和整数操作一样，注意我们表述中使用的 ATT 格式不同于这些文档中使用的 Intel 格式。特别地，这两种版本中列出指令操作数的顺序是不同的。

​		如图3-45所示，AVX 浮点体系结构允许数据存储在 16 个 YMM 寄存器中，它们的名字为 ％ymm0〜％ymm15 。每个 YMM 寄存器都是 256 位（32 字节）。当对标量数据操作时， 这些寄存器只保存浮点数，而且只使用低 32 位（对于float)或 64 位（对于double)。汇编代码用寄存器的 SSE XMM 寄存器名字 ％xmm0〜％xmm15 来引用它们，每个 XMM 寄存器都是对应的 YMM 寄存器的低 128 位（16 字节）

![11媒体寄存器](.\markdownimage\11媒体寄存器.png)



### 浮点传送和转换操作

​		图3-46给出了一组在内存和 XMM 寄存器之间以及从一个 XMM 寄存器到另一个不做任何转换的传送浮点数的指令。引用内存的指令是**标量**指令，意味着它们只对单个而不是一组封装好的数据值进行操作。数据要么保存在内存中（由表中的 M(32) 和 M(64) 指明），要么保存在 XMM 寄存器中（在表中用X表示）。无论数据对齐与否，这些指令都能正确执行，不过代码优化规则建议 32 位内存数据满足 4 字节对齐，64 位数据满足 8 字节对齐。 内存引用的指定方式与整数 MOV 指令的一样，包括偏移量、基址寄存器、变址寄存器和伸缩因子的所有可能的组合。

![11浮点传送指令](.\markdownimage\11浮点传送指令.png)

​		GCC 只用标量传送操作从内存传送数据到 XMM 寄存器或从 XMM 寄存器传送数据到内存。对于在两个 XMM寄存器之间传送数据，GCC 会使用两种指令之一，即用 vmovaps 传送单精度数，用 vmovapd 传送双精度数。对于这些情况，程序复制整个寄存器还是只复制低位值既不会影响程序功能，也不会影响执行速度，所以使用这些指令还是针对标量数据的指令没有实质上的差别。指令名字中的字母 ‘ a ’ 表示 “ aligned(对齐的）” 。 当用于读写内存时，如果地址不满足 16 字节对齐，它们会导致异常。在两个寄存器之间传送数据，绝不会出现错误对齐的状况。

​		下面是一个不同浮点传送操作的例子，考虑以下C函数

```c
float float_mov(float v1, float *src，float *dst) { 
    float v2 = *src;
	*dst = v1; 
    return v2;
}
```

​		与它相关联的 x86-64 汇编代码为

```assembly
;float float_mov(float vl, float *src, float *dst) 
;v1 in %xmmO, src in %rdi, dst in %rsi
1 float_mov:
2	vmovaps %xmmO, %xmm1		;Copy v1
3	vmovss (%rdi), %xmmO		;Read v2 from src
4	vmovss %xmm1, (%rsi)		;Write v1 to dst
5	ret							;Return v2 in %xmmO 
```

这个例子中可以看到它使用了 vmovaps 指令把数据从一个寄存器复制到另一个，使用了 vmovss 指令把数据从内存复制到 XMM 寄存器以及从 XMM 寄存器复制到内存。

​		图3-47和图3-48给出了在浮点数和整数数据类型之间以及不同浮点格式之间进行转换的指令集合。这些都是对单个数据值进行操作的标量指令。图3-47中的指令把一个从 XMM 寄存器或内存中读出的浮点值进行转换，并将结果写入一个通用寄存器（例如 %rax 、％ebx 等）。把浮点值转换成整数时，指令会执行**截断（truncation),**把值向 0 进行舍入，这是 C 和大多数其他编程语言的要求。

![11双、三操作数浮点转换指令](.\markdownimage\11双、三操作数浮点转换指令.png)

​		图3-48中的指令把整数转换成浮点数。它们使用的是不太常见的三操作数格式，有两个源和一个目的。第一个操作数读自于内存或一个通用目的寄存器。这里可以忽略第二个操作数，因为它的值只会影响结果的高位字节。而我们的目标必须是 XMM 寄存器。在最常见的使用场景中，第二个源和目的操作数都是一样的，就像下面这条指令：

`vcvtsi2sdq %rax, %xmm1, %xmm1`

这条指令从寄存器 ％rax 读出一个长整数，把它转换成数据类型 double，并把结果存放进 XMM 寄存器 ％xmm1的低字节中。
		最后，要在两种不同的浮点格式之间转换，GCC 的当前版本生成的代码需要单独说明。假设 ％xmm0 的低位4 字节保存着一个单精度值，很容易就想到用下面这条指令 

`vcvtss2sd %xinmO, %xinmO, %xmm0`

把它转换成一个双精度值，并将结果存储在寄存器 %xmm0 的低 8 字节。不过我们发现 GCC 生成的代码如下

```assembly
;Conversion from single to double precision
1	vunpcklps %xmm0, %xmm0, %xmm0	 		;Replicate first vector element
2	vcvtps2pd %xmm0, %xmm0					;Convert two vector elements to double
```


​		vunpcklps 指令通常用来交叉放置来自两个 XMM 寄存器的值，把它们存储到第三个寄存器中。也就是说，如果一个源寄存器的内容为字[s3, s2，s1，s0]，另一个源寄存器为字[ d3 , d2 , d1 , d0]，那么目的寄存器的值会是[s1，d1，s0 , d0 ]。在上面的代码中，我们看到三个操作数使用同一个寄存器，所以如果原始寄存器的值为[ x3 , x2 , x1，x0]，那么该指令会将寄存器的值更新为值 [ x1,x1,x0, 0]。vcvtps2pd 指令把源 XMM 寄存器中的两个低位单精度值扩展成目的 XMM 寄存器中的两个双精度值。对前面 vunpcklps 指令的结果应用这条指令会得到值[dx0 , dx0 ]，这里 dx0 是将 x 转换成双精度后的结果。



# 未完成