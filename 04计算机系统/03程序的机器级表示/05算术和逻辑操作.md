## 算术和逻辑操作

​		图3-10列出了 x86-64 的一些整数和逻辑操作。大多数操作都分成了指令类，这些指 令类有各种带不同大小操作数的变种（只有 leaq 没有其他大小的变种）。例如，指令类 ADD由四条加法指令组成：addb、addw、addl和 addq ，分别是字节加法、字加法、双字加法和四字加法。事实上，给出的每个指令类都有对这四种不同大小数据的指令。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数， 而一元操作有一个操作数。这些操作数的描述方法与3. 4节中所讲的一样。

![05整数算术操作](.\markdownimage\05整数算术操作.png)

### 加载有效地址

​		**加载有效地址（load effective address)**指令 leaq 实际上是 movq 指令的变形。它的指令形式是从内存读数据到寄存器，<u>但实际上它根本就没有引用内存</u>。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。

​		在图3-10中我们用C语言的地址操作符 &S 说明这种计算。这条指令可以为后面的内存引用产生指针。另外，它还可以简洁地描述普通的算术操作。

例如，如果寄存器 %rdx 的值为 x ，那么指令 

​													leaq 7 (%rdx, %rdx, 4), %rax

将设置寄存器 ％rax 的值为 5x + 7 。编译器经常发现 lea q的一些灵活用法，根本就与有效地址计算无关。目的操作数必须是一个寄存器。

​		为了说明leaq在编译出的代码中的使用，看看下面这个 C 程序：

```c
long scale(long x, long y, long z) { 
    long t = x + 4*y + 12*z; 
    return t;
}
```

​		编译时，该函数的算术运算以三条leaq指令实现，就像右边注释说明的那样：

```assembly
;long  scale(long x , long y , long z)
;x in %rdi, y in %rsi,z in %rdx
scale:
leaq    (%rdi,%rsi,4),%rax     ;x+4*y
leaq    (%rdx,%rdx,2),%rax     ;z+2*z = 3*z
leaq    (%rax,%rdx,4),%rax     ;(x+4*y)+4*(3*z)=x+4*y+12*z
ret
```

​		leaq指令能执行加法和有限形式的乘法，在编译如上简单的算术表达式时，是很有用处的。

#### 练习题3. 6

假设寄存器 ％rax 的值为 x ，％rcx 的值为 y 。填写下表，指明下面每条汇编代码指令存储在寄存器 ％rdx 中的值：


| 表达式                    | 结果   |
| ------------------------- | ------ |
| leaq  6 (%ax), %rdx       | 6+x    |
| leaq  (%rax,%rcx),%rdx    | x+y    |
| leaq  (%rax,%rcx,4),%rdx  | x+4y   |
| leaq  7{%rax,%rax,8),%rdx | 7+9x   |
| leaq  0xA(,%rcx,4),%rdx   | 10+4y  |
| leaq  9(%rax,%rcx,2),%rdx | 9+2y+x |

#### 练习题3.7

考虑下面的代码，我们省略了被计算的表达式：

```c
long seale2(long x, long y, long z) {
    long t =	____________________________________;
    return t;
}
```

​		用GCC编译实际的函数得到如下的汇编代码:

```assembly
;long scale2(long x, long y, long z) 
;x in %rdi, y in %rsi, z in %rdx
scale2:
leaq	(%rdi，％rdi,4),	%rax
leaq	(%rax,%rsi,2),	 %rax
leaq	(%rax,%rdx,8),   %rax
ret
```

填写出C代码中缺失的表达式。
**答：**5x+2y+8z



### —元和二元操作

​		第二组中的操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。比如说，指令 incq(%rsp) 会使栈顶的8字节元素加1 这种语法让人想起C语言中的加1运算符（ + + )和减1运算符（ - - ）。

​		第三组是二元操作，其中，第二个操作数既是源又是目的。这种语法让人想起C语言 中的赋值运算符，例如

x-=y。不过，要注意，源操作数是第一个，目的操作数是第二个， 对于不可交换操作来说，这看上去很奇特。例如，指令 subq%rax,%rdx 使寄存器 %rdx 的值减去 ％rax 中的值。（将指令解读成 “ 从%rdx中减去%rax“会有所帮助。）第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意， 当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。

#### 练习题3. 8

假设下面的值存放在指定的内存地址和寄存器中：

![05公式1](.\markdownimage\05公式1.png)

填写下表，给出下面指令的效果，说明将被更新的寄存器或内存位置，以及得到的值：

| 指令                      | 目的  | 值    |
| ------------------------- | ----- | ----- |
| addq  %rcx, (%rax)        | 0x100 | 0x100 |
| subq  %rdx,8(%rax)        | 0x108 | 0xA8  |
| imulq  $16, (%rax,%rdx,8) | 0x118 | 0x110 |
| incq     16(%rax)         | 0x100 | 0x14  |
| decq    %rcx              | %rcx  | 0x0   |
| subq    %rdx, %rax        | %rax  | 0xFD  |

