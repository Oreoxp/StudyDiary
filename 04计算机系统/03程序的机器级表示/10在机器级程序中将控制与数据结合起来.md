## 在机器级程序中将控制与数据结合起来

​		到目前为止，我们已经分别讨论机器级代码如何实现程序的控制部分和如何实现不同的数据结构。在本节中，我们会看看数据和控制如何交互。首先，深入审视一下指针，它是 C 编程语言中最重要的概念之一，但是许多程序员对它的理解都非常浅显。我们复习符号调试器 GDB 的使用，用它仔细检查机器级程序的详细运行。接下来，看看理解机器级程序如何帮助我们研究缓冲区溢出，这是现实世界许多系统中一种很重要的安全漏洞。最 后，查看机器级程序如何实现函数要求的栈空间大小在每次执行时都可能不同的情况。

### 理解指针

​		指针是 C 语言的一个核心特色。它们以一种统一方式，对不同数据结构中的元素产生引用。对于编程新手来说，指针总是会带来很多的困惑，但是基本概念其实非常简单。在此，我们重点介绍一些指针和它们映射到机器代码的关键原则。

- **每个指针都对应一个类型。**这个类型表明该指针指向的是哪一类对象。以下面的指针声明为例：
  `int * ip; 
  char * * cpp;`
  变量 ip 是一个指向 int 类型对象的指针，而 cpp 指针指向的对象自身就是一个指向 char 类型对象的指针。通常，如果对象类型为 T ，那么指针的类型为 T* 。特殊的 void * 类型代表通用指针。比如说，malloc 函数返回一个通用指针，然后通过显式强制类型转换或者赋值操作那样的隐式强制类型转换，将它转换成一个有类型的指针。指针类型不是机器代码中的一部分；它们是 C 语言提供的一种抽象，帮助程序员避免寻址错误。
- **每个指针都有一个值。**这个值是某个指定类型的对象的地址。特殊的 NULL(0) 值表示该指针没有指向任何地方。
- **指针用‘&’运算符创建。**这个运算符可以应用到任何 lvalue 类的 C 表达式上， lvalue 意指可以出现在赋值语句左边的表达式。这样的例子包括变量以及结构、 联合和数组的元素。我们已经看到，因为 leaq 指令是设计用来计算内存引用的地址的，& 运算符的机器代码实现常常用这条指令来计算表达式的值。
- ***操作符用于间接引用指针。**其结果是一个值，它的类型与该指针的类型一致。间接引用是用内存引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。
- **数组与指针紧密联系。**一个数组的名字可以像一个指针变量一样引用（但是不能修改）。数组引用（例如a[3])与指针运算和间接引用（例如 * (a+ 3)) 有一样的效果。 数组引用和指针运算都需要用对象大小对偏移量进行伸缩。当我们写表达式 P+ i ， 这里指针 P 的值为 f，得到的地址计算为 f+L×i ，这里 L 是与 p 相关联的数据类型的大小。
- **将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。**强制类型转换的一个效果是改变指针运算的伸缩。例如，如果 P 是一个 char*类型 的指针，它的值为 s，那么表达式（int * )P+ 7计算为 s + 28,而（int * ) (P+ 7) 计算为 s + 7。（回想一下，强制类型转换的优先级高于加法。）
- **指针也可以指向函数。**这提供了一个很强大的存储和向代码传递引用的功能，这些引用 可以被程序的某个其他部分调用。例如，如果我们有一个函数，用下面这个原型定义：
  ` int fun(int x, int *p);`
  然后，我们可以声明一个指针 fP ,将它赋值为这个函数，代码如下：
  `int ( *fp) (int, int *); 
  fp = fun;`
  然后用这个指针来调用这个函数： 
  `int y = 1;
  int result = fp(3, &y);`
  函数指针的值是该函数机器代码表示中第一条指令的地址。



### 应用：使用GDB调试器

​		GNU 的调试器 GDB 提供了许多有用的特性，支持机器级程序的运行时评估和分析。 对于本书中的示例和练习，我们试图通过阅读代码，来推断出程序的行为。有了 GDB， 可以观察正在运行的程序，同时又对程序的执行有相当的控制，这使得研究程序的行为变为可能。

​		图3-39给出了一些 GDB 命令的例子，帮助研究机器级 x86-64 程序。先运行 OBJ-DUMP 来获得程序的反汇编版本，是很有好处的。我们的示例都基于对文件 prog 运行 GDB，程序的描述和反汇编见3. 2. 3节。我们用下面的命令行来启动 GDB :
​		linux> gdb prog

​		通常的方法是在程序中感兴趣的地方附近设置断点。断点可以设置在函数入口后面， 或是一个程序的地址处。程序在执行过程中遇到一个断点时，程序会停下来，并将控制返回给用户。在断点处，我们能够以各种方式查看各个寄存器和内存位置。我们也可以单步跟踪程序，一次只执行几条指令，或是前进到下一个断点。

![10GDB命令示例](.\markdownimage\10GDB命令示例.png)

​		正如我们的示例表明的那样，GDB 的命令语法有点晦涩，但是在线帮助信息（用 GDB 的 help 命令调用）能克服这些毛病。相对于使用命令行接口来访问 GDB，许多程序员更愿意使用DDD，它是GDB的一个扩展，提供了图形用户界面。



### 内存越界引用和缓冲区溢出

​		我们已经看到，C 对于数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存的寄存器值和返回地址）都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行 ret 指令时，就会出现很严重的错误。

​		—种特别常见的状态破坏称为**缓冲区溢出（buffer overflow)**。通常，在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。下面这个程序示例就说明了这个问题：

```c
/* Implementation of library function get() */ 
char *gets(char *s){
	int c;
	char *dest = s;
	while ((c = getchar()) != '\n' && c != EOF)
		*dest++ = c;
	if (c == EOF && dest == s)
        /* No characters read */ 
        return NULL;
	*dest++ = '\0'; /* Terminate string */
	return s;
}

/* Read input line and write it back */ 
void echo(){
	char buf [8];	/* Way too small! */
	gets(buf);
	puts(buf);
}
```

​		前面的代码给出了库函数 gets 的一个实现，用来说明这个函数的严重问题。它从标准输入读入一行，在遇到一个回车换行字符或某个错误情况时停止。它将这个字符串复制到参数 f 指明的位置，并在字符串结尾加上 null 字符。

​		在函数 ech() 中，我们使用了 gets ,  这个函数只是简单地从标准输入中读入一行，再把它回送到标准输出。
gets 的问题是它没有办法确定是否为保存整个字符串分配了足够的空间。在 echo示例中，我们故意将缓冲区设得非常小——只有 8 个字节长。任何长度超过 7个 字符的字符串都会导致写越界。

​		检查 GCC 为 echo 产生的汇编代码，看看栈是如何组织的：

```assembly
;void echoO 
1 echo:
2	subq	$24， %rsp			;Allocate 24	bytes on stack
3	movq	%rsp, %rdi			;Compute buf	as %rsp
4	call	gets				;Call gets	
5	movq	%rsp， %rdi          ;Compute buf	as %rsp
6	call	puts				;Call puts	
7	addq	$24, %rsp			;Deallocate stack space	
8	ret							;Return	
```


​		图3-40画出了 echo 执行时栈的组织。该程序把栈指针减去了 24(第2行），在栈上分配了 24 个字节。字符数组 buf 位于栈顶，可以看到，％rsp 被复制到红也作为调用 gets 和 puts 的参数。这个调用的参数和存储的返回指针之间的 16 字节是未被使用的。只要用户输入不超过7个字符，gets 返回的字符串（包括结尾的null)就能够放进为 buf 分配的