## 数组分配和访问

​		C 语言中的数组是一种将标量数据聚集成更大数据类型的方式。C 语言实现数组的方式非常简单，因此很容易翻译成机器代码。C 语言的一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址计算。

​		优化编译器非常善于简化数组索引所使用的地址计算。不过这使得 C 代码和它到机器代码的翻译之间的对应关系有些难以理解。

### 基本原则

​		对于数据类型T和整型常数 N ，声明如下：

​		 **T A[N]；**
起始位置表示为 x(A) 。这个声明有两个效果。首先，它在内存中分配一个 L x N 字节的连续区域，这里 L 是数据类型 T 的大小（单位为字节）。其次，它引人了标识符 A ,可以用 A 来作为指向数组开头的指针，这个指针的值就是 x(A) 。可以用 0〜N-1 的整数索引来访问该数组元素。数组元素 i 会被存放在地址为的地方。

​		作为示例，让我们来看看下面这样的声明：

```C
char	A[12];
char	*B[8];
int		C[6];
double  *D[5];
```


​		这些声明会产生带下列参数的数组:

| 数组 | 元素大小 | 总的大小 | 起始地址 | 元素 i |
| ---- | -------- | -------- | -------- | ------ |
| A    | 1        | 12       | X(A)     | X(A)+i |
| B    | 8        | 64       | X(B)     | X(B)+i |
| C    | 4        | 24       | X(C)     | X(C)+i |
| D    | 8        | 40       | X(D)     | X(D)+i |

​		数组 A 由 12 个单字节（char)元素组成。数组 C 由 6 个整数组成，每个需要8个字节。 B 和 D 都是指针数组，因此每个数组元素都是 8 个字节。

​		x86-64 的内存引用指令可以用来简化数组访问。例如，假设 E 是一个 int 型的数组, 而我们想计算 E[i] ，在此，E 的地址存放在寄存器 ％rdx 中，而 i 存放在寄存器 ％rcx 中。 然后，指令

​		`movl (%rdx,%rcx,4),%eax`

会执行地址计算 x(E) + 4i ，读这个内存位置的值，并将结果存放到寄存器 ％eax 中。允许的伸缩因子1、2、4和8覆盖了所有基本简单数据类型的大小。



### 指针运算

​		C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果P 是一个指向类型为了的数据的指针，p的值为 x(p)，那么表达式 p+i的值为X(P) + L •i，这里L是数据类型了的大小。

​		单操作数操作符‘&’和可以产生指针和间接引用指针。也就是，对于一个表示某 个对象的表达式Expr，&Expr是给出该对象地址的一个指针。对于一个表示地址的表达 式AExpr，*AExpr给出该地址处的值。因此，表达式Expr与* &Expr是等价的。可以对 数组和指针应用数组下标操作。数组引用A[i]等同于表达式* (A+ i)。它计算第〖个数 组元素的地址，然后访问这个内存位置。

​		扩展一下前面的例子，假设整型数组E的起始地址和整数索引〖分别存放在寄存器 中。下面是一些与E有关的表达式。我们还给出了每个表达式的汇编代码实 现，结果存放在寄存器％eax(如果是数据）或寄存器％!：狀(如果是指针）中。