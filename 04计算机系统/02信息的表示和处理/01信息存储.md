### 信息存储

​		大多数计算机使用8位的块，或者**字节（byte)**，作为最小的可寻址的内存单位，而不 是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存 (virtual memory）**。内存的每个字节都由一个唯一的数字来标识，称为它的**地址（address）**， 所有可能地址的集合就称为**虚拟地址空间 （virtual address space)** 。 顾名思义 ，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现（见第9章）是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

​		在接下来的几章中，我们将讲述编译器和运行时系统是如何将存储器空间划分为更可管理的单元，来存放不同的**程序对象（program object）**，即程序数据、指令和控制信息。 可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。例如，C语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象)都是某个存储块的第一个字节的虚拟地址。C编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管C编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。

#### 2.1.1十六进制表示法

​		—个字节由8位组成。在二进制表示法中，它的值域是00000000(2)〜11111111(2)。如果看 成十进制整数，它的值域就是〇(10)〜255(10)。。两种符号表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。替代的方法是， 以16为基数，或者叫做**十六进制（hexadecimal)**数，来表示位模式。十六进制（简写为“hex”) 使用数字‘0’〜‘9’以及字符‘A‘〜‘F’来表示16个可能的值。图2-2展示了 16个十六进制数字对应的十进制值和二进制值。用十六进制书写，一个字节的值域为00(16)〜FF(16)。

![01十六进制表示法](.\markdownimage\01十六进制表示法.png)

​		在C语言中，以Ox或0X开头的数字常量被认为是十六进制的值。字符‘A’〜‘F’ 既可以是大写，也可以是小写。例如，我们可以将数字FA1D37B1S写作0XFA1D37B，或者 0xfald37b,甚至是大小写混合，比如，0xFalD37b。在本书中，我们将使用C表示法来表示十六进制值。

​		编写机器级程序的一个常见任务就是在位模式的十进制、二进制和十六进制表示之间人工转换。二进制和十六进制之间的转换比较简单直接，因为可以一次执行一个十六进制数字的转换。数字的转换可以参考如图2-2所示的表。一个简单的窍门是，记住十六进制数字A、C和F相应的十进制值。而对于把十六进制值B、D和E转换成十进制值，则可以通过计算它们与前三个值的相对关系来完成。

比如，假设给你一个数字0x173A4C。可以通过展开每个十六进制数字，将它转换为二进制格式，如下所示：
		十六进制	   1	      7	       3	       A	      4	       C
		二进制	0001	0111	0011	1010	0100	1100
		这样就得到了二进制表示000101110011101001001100。

​		反过来，如果给定一个二进制数字1111001010110110110011，可以通过首先把它分为 每4位一组来转换为十六进制。不过要注意，如果位总数不是4的倍数，最左边的一组可 以少于4位，前面用0补足。然后将每个4位组转换为相应的十六进制数字：
二进制	  11	1100	1010	1101	1011	0011
十六进制	3	      C	       A	      D	      B	       3