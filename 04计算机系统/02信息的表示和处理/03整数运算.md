### 整数运算

​		许多刚人门的程序员非常惊奇地发现，两个正数相加会得出一个负数，而比较表达式 x<y 和比较表达式 x-y<0会产生不同的结果。这些属性是由于计算机运算的有限性造成的。 理解计算机运算的细微之处能够帮助程序员编写更可靠的代码。

#### 无符号加法

​		考虑两个非负整数 x 和 y ,满足 0 <= x, y < 2^w。每个数都能表示为 w 位无符号数字。然而， 如果计算它们的和，我们就有一个可能的范围 0 <= x+y <=2^(w+1) - 2。表示这个和可能需要 w+1 位。

​		例如，图2-21展示了当x和 y 有4位表示时，函数 x+y 的坐标图。参数(显示在水平轴上)取值范围为 0〜15,但是和的取值范围为0〜30。函数的形状是一个有坡度的平面(在两个维度上，函数都是线性的）。如果保持和为一个 w+1 位的数字，并且把它加上另外一个数值，我们可能需要 w+2 个位，以此类推。

​		这种持续的 “字长膨胀”意味着，要想完整地表示算术运算的结果，我们不能对字长做任何限制。一些编程语言，例如Lisp,实际上就支持无限精度的运算，允许任意的(当然，要在机器的内存限制之内）整数运算。更常见的是，编程语言支持固定精度的运算，因此像“加法”和“乘法”这样的运算不同于它们在整数上的相应运算。

![03整数加法](.\markdownimage\03整数加法.png)

​		让我们为参数 x 和 y 定义运算 +(u)(w) 其中 0 <=x , y<2^w 该操作是把整数和 x+y 截断为 w 位得到的结果，再把这个结果看做是一个无符号数。这可以被视为一种形式的模运算，对 x+y 的位级表示，简单丢弃任何权重大于  2^(w-1) 的位就可以计算出和模 2^w 。比如， 考虑一个4位数字表示，x = 9 和 y = 12 的位表示分别为 [1001] 和[1100]。它们的和是 21， 5位的表示为[10101]。但是如果丢弃最高位，我们就得到[0101]，也就是说，十进制值 的 5。这就和值 21 mod 16 = 5 —致。

![03公式1](.\markdownimage\03公式1.png)

​		图2-22说明了公式（2. 11）的这两种情况，左边的和 x+ y 映射到右边的无符号 w 位的和 x +(u)(w) y。正常情况下 x+ y 的值保持不变，而溢出情况则是该和数减去 2^w 的结果。

![03整数加法和无符号加法的关系](.\markdownimage\03整数加法和无符号加法的关系.png)

**推导**：*无符号数加法*

​		—般而言，我们可以看到，如果 x+y < 2^w , 和的 w+1 位表示中的最高位会等于0，因此丢弃它不会改变这个数值。另一方面，如果 2^w <= x+y <= 2^(w+1) ，和的 w+1 位表示中的最高位会等于 1，因此丢弃它就相当于从和中减去了 2^w 。

​		说一个算术运算**溢出**，是指完整的整数结果不能放到数据类型的字长限制中去。如等式 (2. 11) 所示，当两个运算数的和为 2^w 或者更大时，就发生了溢出。

​		图2-23展示了字长 w = 4 的无符号加法函数的坐标图。这个和是按模 2^4 = 16 计算的。当 x+y < 16 时，没有 溢出，并且 x +(u)(4) y就是 x+y 。这对应于图中标记为“正常”的斜面。当 x + y >= 16时，加法溢出，结果相当于从和中减去16。这对应于图中标记为“溢出”的斜面。

![03无符号加法(4位字长，加法是模16的)](.\markdownimage\03无符号加法(4位字长，加法是模16的).png)

​		当执行C程序时，不会将溢出作为错误而发信号。不过有的时候，我们可能希望判定 是否发生了溢出。

​		**原理**：*检测无符号数加法中的溢出*

​		对在范围 0 <= x，y <= UMax(w) 中的 x 和 y，令 s = x +(u)(w) b。则对计算s，**当且仅当 s < x (或者等价地s < y) 时，发生了溢出。**

​		作为说明，在前面的示例中，我们看到 9 +(u)(4) 12 = 5。由于 5<9 ,我们可以看出发生了 溢出。

​		**推导**：*检测无符号数加法中的溢出*

​		通过观察发现 x+y >= x，因此如果 s 没有溢出，我们能够肯定 s >= x 。 另一方面，如果 s 确实溢出了，我们就有 s = x + y —2^w 。假设：y < 2^w ，我们就有 y —2^w < 0 ，因此  s = x+(y - 2^w) < x。

​		模数加法形成了一种数学结构，称为**阿见尔群（Abelian group）**，这是以丹麦数学家 Niels Henrik Abel(1802〜1829)的名字命名。也就说，它是可交换的（这就是为什么叫 “abelian”的地方）和可结合的。它有一个单位元 0 ,并且每个元素有一个加法逆元。让我们考虑 w 位的无符号数的集合，执行加法运算 +(u)(w)。 **对于每个值 x ，必然有某个值 -(u)(w)x 满足 -(u)(w)x + (u)(w)x = 0 。**该加法的逆操作可以表述如下：

​		**原理**：*无符号数求反*

![03公式2](.\markdownimage\03公式2.png)

该结果可以很容易地通过案例分析推导出来：

​		**推导**：*无符号数求反*

​		当 x = 0 时，加法逆元显然是 0。对于 x > 0,考虑值 2^w-x 。我们观察到这个数字在  0 < 2^w — x < 2^w 范围之内，并且（x + 2^w -x ) mod 2^w = 2^w mod 2^w = 0 。因此，它就是 x 在 +(u)(w) 下的逆元。

### 补码加法

​		对于补码加法，我们必须确定当结果太大（为正）或者太小（为负）时，应该做些什么。给定在范围 -2^(w-1) <= x , y <= 2^(w-1) - 1 之内的整数值 x 和 y ，它们的和就在范围 -2^w <= x+y <= 2^w-2 之内，要想准确表示，可能需要 w+1 位。

​		就像以前一样，我们通过将表示截断到 w 位，来避免数据大小的不断扩张。然而，结果却不像模数加法那样在数学上感觉很熟悉。定义 x +(t)(w) y 为整数和 x+y 被截断为 w 位的结果，并将这个结果看做是补码数。

​		**原理**：*补码加法*

![03公式3](.\markdownimage\03公式3.png)

​		图2-24说明了这个原理，其中，左边的和 x + y 的取值范围为 -2^w <= x + y <= 2^w - 2 ,右边显示的是该和数截断为w位补码的结果。（图中的标号“情况1” 到“情况4”用于该原理形式化推导的案例分析中。）

当和 x+y 超过 TMax(w) 时(情况4)，我们说发生了**正溢出**。在这种情况下，截断的结果是从和数中减去 2^w。
当和 x+y 小于 TMin(w)  时(情况1)，我们说发生了**负溢出**。在这种情况下，截断的结果是把和数加上 2^w。

​		两个数的 w 位补码之和与无符号之和有完全相同的位级表示。实际上，大多数计算机使用同样的机器指令来执行无符号或者有符号加法。

![03整数和补码加法之间的关系](.\markdownimage\03整数和补码加法之间的关系.png)

​		**推导**：*补码加法*

​		既然补码加法与无符号数加法有相同的位级表示， 我们就可以按如下步骤表示运算 +(t)(w)：将其参数转换为无符号数，执行无符号数加法，再将结果转换为补码：

![03公式4](.\markdownimage\03公式4.png)

​		根据等式 (2.6) ，我们可以把 T2U(w)(x) 写成：x(w-1)2^w + x，把 T2U(w)(y) 写成 y(w-1)x2^w + y。 使用属性，即 +(u)(w) 是模 2^w 的加法，以及模数加法的属性，我们就能得到：

![03公式5](.\markdownimage\03公式5.png)

消除了 x(w-1) 2^w 和 y(w-1) 2^w 这两项，因为它们模 2^w 等于0。

![03公式6](.\markdownimage\03公式6.png)

![03公式7](.\markdownimage\03公式7.png)

​		图2-26阐述了字长 w = 4 的补码加法。运算数的范围为 -8〜7 之间。当 x+y < — 8 时，补码加法就会负溢出，导致和增加了 16。当 一8 < x+y < 8时，加法就产生 x + y。当 x+y > 8 加法就会正溢出，使得和减少了 16。这三种情况中的每一种都形成了图中的一个斜面。

![03补码加法](.\markdownimage\03补码加法.png)

​		等式(2. 13)也让我们认出了哪些情况下会发生溢出：

​		**原理**：*检测补码加法中的溢出*

![03公式8](.\markdownimage\03公式8.png)
		图2-25显示了 w = 4 当时，这个原理的例子。第一个条目是负溢出的情况，两个负数相加得到一个正数。最后一个条目是正溢出的情况，两个正数相加得到一个负数。

​		**推导**：*检测补码加法中的溢出*

​		让我们先来分析正溢出。

​		如果 x > 0 ，y > 0,而 s <= 0 , 那么显然发生了正溢出。

​		反过来，正溢出的条件为：

​		**1) x > 0, ：y>0(或者 x+y < TMax(w)),** 

​		**2) s <=0 (见公式（2. 13))。**

​		同样的讨论也适用于负溢出情况。

### 补码的非

​		可以看到范围在 TMin(w) <= x <= TMax(w) 中的每个数字 x 都有 +(t)(w) 下的加法逆元，我们将 -(t)(w)x 表示如下。

​		**原理**：*补码的非*

![03公式9](.\markdownimage\03公式9.png)

​		也就是说，对 w 位的补码加法来说，TMin(w) 是自己的加法的逆，而对其他任何数值 x 都有 -x 作为其加法的逆。
​		**推导**：*补码的非*

​		观察发现![03公式10](.\markdownimage\03公式10.png)这将导致负溢出，因此![03公式11](.\markdownimage\03公式11.png)。对满足 x > TMin(w) 的 x，数值 - x 可以表示为一个 w 位的补码，它们的和 - x + x = 0。



### 无符号乘法

​		范围在 0 <= x，y < 2^w一1 内的整数 x 和 y 可以被表示为 w 位的无符号数，但是它们的乘积 x • y 的取值范围为 0 到 (2^w -1)^2 = 2^(2w) - 2^(w+1) + 1 之间。这可能需要 2w 位来表示。不过，C 语言中的无符号乘法被定义为产生 w 位的值，就是 2w 位的整数乘积的低 w 位表示的值。我们将这个值表示为 x*(u)(w) y 以。
​		将一个无符号数截断为 w 位等价于计算该值模 2^w , 得到：

​		**原理**：*无符号数乘法*

​		对满足 0 <= x， y <= UMax(w) 的 x 和 y 有：

![03公式12](.\markdownimage\03公式12.png)

### 补码乘数

​		范围在  -2^(w-1) <= x，y <= 2^(w-1) - 1 内的整数 x 和 y 可以被表示为 w 位的补码数字，但是它们的乘积 x • y 的取值范围为 - 2^(w-1) •( 2^(w-1) - 1 ) = -2^(2w-2) + 2^(w-1) 到( - 2^(w-1)) •(  - 2^(w-1)) =  - 2^(2w-2) 之间。要想用补码来表示这个乘积，可能需要 2w 位。然而，C 语言中的有符号乘法是通过将 2w 位的乘积截断为 w 位来实现的。我们将这个数值表示为 x *(t)(w) y。将一个补码数截断为 w 位相当于先计算该值模2^w，再把无符号数转换为补码，得到：

​		**原理**：*补码乘法*

![03公式13](.\markdownimage\03公式13.png)

​		我们认为对于无符号和补码乘法来说，乘法运算的位级表示都是一样的，并用如下原理说明：
​		**原理**：*无符号和补码乘法的位级等价性*

![03公式14](.\markdownimage\03公式14.png)

​		作为说明，图2-27给出了不同3位数字的乘法结果D对于每一对位级运算数，我们 执行无符号和补码乘法，得到6位的乘积，然后再把这些乘积截断到3位。无符号的截断 后的乘积总是等于:r*：y mod 8。虽然无符号和补码两种乘法乘积的6位表示不同，但是截 断后的乘积的位级表示都相同。

​		**推导**：*无符号和补码乘法的位级等价性*

![03公式15](.\markdownimage\03公式15.png)

![03公式16](.\markdownimage\03公式16.png)

### 乘以常数

​		以往，在大多数机器上，整数乘法指令相当慢，需要 10 个或者更多的时钟周期，然而其他整数运算（例如加法、减法、位级运算和移位）只需要1个时钟周期。即使在我们的参考机器 Intel Core i7 Haswell 上，其整数乘法也需要3个时钟周期。因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。首先，我们会考虑乘以2的幂的情况，然后再概括成乘以任意常数。
​		**原理**：*乘以 2 的幂*

![03公式17](.\markdownimage\03公式17.png)

​		因此，比如，当 w = 4 时，11可以被表示为[1011]。k = 2 时将其左移得到 6 位向量 [101100]，即可编码为无符号数11• 4 = 44。
​		**推导**：*乘以2的幂*

![03公式18](.\markdownimage\03公式18.png)

​		当对固定字长左移6位时，其高6位被丢弃，得到

![03公式19](.\markdownimage\03公式19.png)

而执行固定字长的乘法也是这种情况。因此，我们可以看出左移一个数值等价于执行一个 与2的幂相乘的无符号乘法。
		**原理**：*与 2 的幂相乘的无符号乘法*

​		C 变量 x 和 k 有无符号数值 x 和 k ，且 0 <= k < w，则 C 表达式 x << k 产生数值![03公式20](.\markdownimage\03公式20.png)。

​		由于固定大小的补码算术运算的位级操作与其无符号运算等价，我们就可以对补码运 算的2的幂的乘法与左移之间的关系进行类似的表述：

​		**原理**：*与 2 的幂相乘的补码乘法*

​		C 变量 x 和 k 有补码值 x 和无符号数值 k ，且 0 <= k <w，则 C 表达 x << k 产生数值![03公式21](.\markdownimage\03公式21.png) 

​		注意，无论是无符号运算还是补码运算，乘以 2 的幂都可能会导致溢出。结果表明， 即使溢出的时候，我们通过移位得到的结果也是一样的。回到前面的例子，我们将4位模式[1011]（数值为11）左移两位得到[101100]（数值为44）。将这个值截断为4位得到 [1100]（数值为 12 = 44 mod 16）。

​		由于整数乘法比移位和加法的代价要大得多，许多C语言编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况。例如，假设一个程序包含表达式 x * 14。利用 14 = 2^3 +2^2 + 2^1，编译器会将乘法重写为（ x << 3 ) + ( x << 2 ) + ( x << 1 )，将一个乘法替换为三个移位和两个加法。无论 x 是无符号的还是补码，甚至当乘法会导致溢出时，两个计算都会得到一样的结果。（根据整数运算的属性可以证明这一点。）更好的是，编译器还可以利用属性 14 = 2^4—2^1，将乘法重写为（ x << 4 ) - ( x << 1)，这时只需要两个移位和一个减法。



​	归纳一下我们的例子，考虑一个任务，对于某个常数 K 的表达式 x * K 生成代码。编译器会将 K 的二进制表示表达为一组 0 和 1 交替的序列：

​															[(0 …0)(1…1)(0 …0)…(1…1)]

例如，14 可以写成 [(0…0)(111)(0)] 。考虑一组从位位置 n 到位位置 m 的连续的 1 ( n >= m ）。（对于 14 来说，我们有 n = 3 和 m = 1。）我们可以用下面两种不同形式中的一种来计算这些位对乘积的影响：

​			形式 A： (x << n) + ( x << ( n - 1)) +  ...  + ( x << n )
​			形式 B:：( x << ( n + 1 ) ) - ( x << m )

把每个这样连续的 1 的结果加起来，不用做任何乘法，我们就能计算出 x * K。当然，选择使用移位、加法和减法的组合，还是使用一条乘法指令，取决于这些指令的相对速度， 而这些是与机器高度相关的。大多数编译器只在需要少量移位、加法和减法就足够的时候才使用这种优化。

### 除以 2 的幂

​		在大多数机器上，整数除法要比整数乘法更慢——需要30个或者更多的时钟周期。除以2的幂也可以用移位运算来实现，只不过我们用的是右移，而不是左移。无符号和补码数分别使用逻辑移位和算术移位来达到目的。

![03公式22](.\markdownimage\03公式22.png)

​		对无符号运算使用移位是非常简单的，部分原因是由于无符号数的右移一定是逻辑右移。

​		**原理**：*除以2的幂的无符号除法*

​		C 变量 x 和 k 有无符号数值 x 和 k，且0 <= k < w , 则C表达式 x >> k 产生数值 [x / 2^k ]。

​		例如，图2-28给出了在12 340的16位表示上执行逻辑右移的结果，以及对它执行除 以1、2、16和256的结果。从左端移人的0以斜体表示。我们还给出了用真正的运算做除法得到的结果。这些示例说明，移位总是舍人到零的结果，这一点与整数除法的规则一样。

![03无符号数除以2的幂](.\markdownimage\03无符号数除以2的幂.png)

![03公式23](.\markdownimage\03公式23.png)

这个位向量有数值 x' ,我们看到，该值可以通过计算 x >> k 得到。

​		对于除以2的幂的补码运算来说，情况要稍微复杂一些。首先，为了保证负数仍然为负，移位要执行的是算术右移。现在让我们来看看这种右移会产生什么结果。

​		**原理**：*除以 2的幂的补码除法，向下舍入*

​		C 变量 x 和 k 分别有补码值 x 和无符号数值 k ，且 0 <= k < w，则当执行算术移位时， C表达式 x >> k 产生数值 [ x / 2^k ]。

​		对于 x >= 0，变量 x 的最高有效位为 0 ，所以效果与逻辑右移是一样的。因此，对于非负数来说，算术右移 k 位与除以 2^k 是一样的。作为一个负数的例子，图2-29给出了对  -12 340 的 16 位表示进行算术右移不同位数的结果。对于不需要舍人的情况 ( k = 1 )，结果是 x / 2^k 。 但是当需要进行舍人时，移位导致结果向下舍人。例如，右移 4 位将会把 -771. 25 向下舍入为 -772。我们需要调整策略来处理负数 x 的除法。

![03进行算术右移](.\markdownimage\03进行算术右移.png)

​		**推导**：*除以2的幂的补码除法，向下舍入*

![03公式24](.\markdownimage\03公式24.png)

​		我们可以通过在移位之前“**偏置（biasing)**”这个值，来修正这种不合适的舍入。
​		**原理**：*除以2的幂的补码除法，向上舍入*

​		C变量 x 和 k 分别有补码值 x 和无符号数值 k ，且 0 <= k < w ，则当执行算术移位时， C 表达式（x+ ( 1 << k) - 1) >> k 产生数值 [ x/2^k ]。

​		图2-30说明在执行算术右移之前加上一个适当的偏置量是如何导致结果正确舍入的。 在第 3 列，我们给出了  -12 340加上偏量值之后的结果，低 k 位（那些会向右移出的位）以斜体表示。我们可以看到，低 k 位左边的位可能会加 1，也可能不会加 1。对于不需要舍入的情况 (k = 1)，加上偏量只影响那些被移掉的位。对于需要舍入的情况，加上偏量导致较高的位加1，所以结果会向零舍入。

![03补码除以2的幂](.\markdownimage\03补码除以2的幂.png)

​		**推导**：*除以2的幂的补码除法，向上舍入*