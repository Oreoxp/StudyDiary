## 一、纹理应用

​		`纹理`概述：在现代 GPU 中， texture = memory + range query (Filtering)，即纹理其实就是存储在GPU上的一块内存上的数据，然后我们可以对这块内存做区域查询（例如MipMap）。

常用的纹理应用有如下：

- Environment lighting (环境光)
- Store microgeometry
- Procedural textures
- Solid modeling
- Volume rendering

### 1.1 Environment Map 环境光照/环境贴图

![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220507/1651894659319235695.png)

​		通常一个光滑的表面（比如水晶球）会反射环境光，因此我们可以看到球面上会被映射出其他物体。那么计算机中如何表示这个呢？
​		一种方法是`Spherical Environment Map`，即先把环境光信息记录在球面上，其中还包括了球面与二维平面之间的映射关系。

![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220507/1651895402836558307.png)

​		但是上面这种方法会有一个问题，即映射到二维平面后会导致扭曲，如下图示：
![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220507/1651895430011965277.png)

既然球面会导致扭曲，那么一种改进的思路如下,即我们不再把信息记录在球上，而是记录在一个立方体的表面上，这个立方体会包住原来的球体。

![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220507/1651895463958133662.png)
![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220507/1651896037943735588.png)

当然这也也会有问题：方向要先判断记在cube上的

### 1.2 纹理可以影响 shading

纹理不仅可以存储颜色，还可以存储高度等信息，即可以“伪造”详细的几何。

我们可以看到下图的橘子会有坑坑洼洼的感觉，那这种效果如何实现呢？

- 一种方式是构造出一种复杂的形状来显示出凹凸感，但是这样实现起来会比较复杂；
- 另一种方式就是通过法线贴图来实现，这种方法的一个大致的思路是比如纹理全部是橘色的，只不过在映射到二维平面时，我们会调整每个纹理的法向。前面我们有介绍过法线方向的改变会导致光的亮度等变换，这样就等同于像素之间有了明暗变化，所以就有了凹凸感。

![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220507/1651904016726226516.png)

​		上面提到的法线贴图方法并不需要改变任何几何信息，即不需要增加二维平面划分成更多的三角形。那具体是怎么实现的呢？这需要用到`Bump Mapping`技术。

#### 1.2.1 Bump Mapping 凹凸贴图

​		`Bump Mapping`就是对每个像素的平面法向做扰动。如下图示，黑色曲线表示真实的物体光滑表面，而黄色曲线则是扰动后的效果。我们可以看到原来的P点的法向经过扰动后发生了改变，这样就可以实现法线贴图。

​		概括讲：通过定义不同高度邻近位置的高度差，来重新计算法线。
![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220507/1651904037596357070.png)

扰动后的法向如何计算呢？

##### flatland case

​		首先看一下在一维情况（flatland case）下如何计算，假设下图中的点为 P 点。

​		P点原始的法线方向是朝上的，即 n(p) = (0,1)。
​		下图中的蓝色曲线表示法线贴图，那么 P 点横向移动一个单位后，向上则会移动 dpdp , (假设 P 点会朝着切线方向运动 )。切线方向即为该点的梯度，由梯度计算公式可知 dp=c∗[h(p+1)−h(p)]，其中 c 为一个常量，所以切线可表示为 (1,dp)。
​		既然知道了切线方向，那么法线方向就很容易计算出来了，即切线方向逆时针旋转 90° 即可,所以扰动后的法线方向为 n(p) = (−dp,1).normalized()

![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220507/1651904478224210715.png)

##### 3D case

​		同理在 3D 情况下则有两个方向的变换，即 u, v 方向。

​		需要注意的是 flatland 和 3D 这两种情况下我们都假设某点的法向是朝上的，所以说这个假设的法线方向其实是基于一个局部的坐标构建的。

![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220507/1651904502723573714.png)

#### 1.2.2 Displacement mapping 位移贴图

​		上述方法其实是通过对法线方向扰动实现凹凸效果，还有一种方法是位移贴图。

![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220507/1651904559852142299.png)

​		位移贴图和法线贴图使用的纹理是一样的，只不过位移贴图不再变换法线方向，而是真实地对每个三角形的顶点做一定的位移。上图中可以看出两种方法的区别。

​		左边的是法线贴图，可以看到它并没有改变物体形状（还是圆形），另外影子投影结果也是一个光滑球体的投影，所以这种方法其实是一种假象，欺骗了人的眼睛。

​		右边是位移贴图，可以看到凹凸感很明显，而且投影也体现出了这种凹凸感，比如凸起部位的投影也都显示出来了。

​		上面的对比可以看出位移贴图虽然效果更好，因为他需要对把物体划分成更多的三角形，即物体需要被划分的更加细致，这样才能更准确地描述出凹凸特点，但是它的计算量也是更大的。

​		DirectX 中的动态曲面细分：开始先用粗糙的三角形，应用Texture的过程中检测是否需要把三角形拆分的更细

### 1.3 三维纹理

​		上面介绍的纹理应用都是应用在二维平面的，那么很自然就有三维的纹理应用。三维纹理的意思就是除了物体表面有纹理，物体内部也是有纹理的，而内部的纹理通常是通过生成某种三维噪声然后再做处理得到的。比如下图示展示的`Perlin noise（柏林噪声）`，就可以得到一种大理石纹理的效果。

![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220507/1651904639947806061.png)

### 1.4 Texture可以记录一些已经算好的信息

​		例如：`环境光遮蔽（Ambient Occlusion）`阴影可以计算好，直接写在Texture里。

![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220507/1651904711229514004.png)

### 1.5 3D Texture 和体积渲染

​		还有一种三维纹理的应用时医学上的应用，即 volume rendering（体渲染）
![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220507/1651904667249913878.png)